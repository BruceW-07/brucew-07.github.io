[{"categories":["OI","学习笔记"],"content":"简介 Splay 维护平衡的方式就是每访问到一个节点, 都把它旋转到根. 这个把节点 x 旋转到根的过程就叫做 Splay. ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:1:0","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","学习笔记"],"content":"维护变量 int rt, fa[_], ch[_][2], val[_], num[_], sum[_]; rt: 根节点. fa[u]: 节点 u 的父节点. ch[u][0/1]: 节点 u 的左右儿子. val[u]: 节点 u 的权值. num[u]: 权值为 val[u] 的元素个数. sum[u]: 节点 u 的子树 num 之和. ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:2:0","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","学习笔记"],"content":"主要操作 ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:3:0","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","学习笔记"],"content":"Update void upd(int x) { sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + num[x]; } ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:3:1","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","学习笔记"],"content":"Rotate 和 Treap 的 Rotate 没啥区别. void Rotate(int x) { int y = fa[x], t = get(x); ch[y][t] = ch[x][!t], fa[ch[x][!t]] = ch[x][!t] ? y : 0; // modify ch[x][!t] fa[x] = fa[y], ch[fa[x]][get(y)] = fa[x] ? x : 0; // modify x ch[x][!t] = y, fa[y] = x; // modify y upd(y), upd(x); } ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:3:2","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","学习笔记"],"content":"Splay 设 get(u) = 0/1 表示 u 是 fa[u] 的左/右儿子. 为了保证平衡, 若有 get(u) == get(fa[u]), 则要先 Rotate(fa[u]) 后再 Rotate(u). void Splay(int x) { while (fa[x]) { if (fa[fa[x]] and get(fa[x]) == get(x)) Rotate(fa[x]); Rotate(x); } rt = x; } ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:3:3","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","学习笔记"],"content":"Insert 一直往下找, 若有 val[u] == w, 则 ++num[u]; 若到了空节点, 则新建节点. 最后 Splay. void Ins(int \u0026u, int f, int w) { if (!u) { u = ++tot, fa[u] = f, val[u] = w, num[u] = sum[u] = 1; Splay(u); return; } if (val[u] == w) { ++num[u], ++sum[u]; Splay(u); return; } Ins(ch[u][val[u] \u003c w], u, w); } void Ins(int w) { Ins(rt, 0, w); } 多写一个是为了方便调用. ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:3:4","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","学习笔记"],"content":"Merge 设合并的两棵树为 A, B, 则需满足 A 的最大值小于 B 的最小值. 若有一棵树为空, 则将另外一棵树的根节点设为根. 否则将 A 中的最大值 Splay 到根, 然后将 B 设为 A 的右子树. (记得更新相关信息). void Merge(int x, int y) { if (!x) { rt = y, fa[y] = 0; return; } //** rt = x, fa[x] = 0; while (ch[x][1]) x = ch[x][1]; Splay(x); ch[rt][1] = y, fa[y] = rt, upd(rt); //** } (//** 是容易写错的地方.) ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:3:5","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","学习笔记"],"content":"Delete 若有 num[u] \u003e 1, 则 --num[u]. 否则将 Splay(u), 然后合并 u 的两棵子树. void Del(int w) { Find(rt, w); if (num[rt] \u003e 1) --num[rt]; else Merge(ch[rt][0], ch[rt][1]); } ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:3:6","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","学习笔记"],"content":"其他 找排名, 找第 k 小 / 大, 找前驱, 找后继. 都和 Treap 差不多. ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:3:7","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","学习笔记"],"content":"代码 #include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 1e5 + 7; struct SPLAY { #define get(x) (x == ch[fa[x]][1]) int rt, fa[_], ch[_][2], num[_], sum[_], val[_], tot; void upd(int x) { sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + num[x]; } void Rotate(int x) { int y = fa[x], t = get(x); ch[y][t] = ch[x][!t], fa[ch[x][!t]] = ch[x][!t] ? y : 0; // modify ch[x][!t] fa[x] = fa[y], ch[fa[x]][get(y)] = fa[x] ? x : 0; // modify x ch[x][!t] = y, fa[y] = x; // modify y upd(y), upd(x); } void Splay(int x) { while (fa[x]) { if (fa[fa[x]] and get(fa[x]) == get(x)) Rotate(fa[x]); Rotate(x); } rt = x; } void Ins(int \u0026u, int f, int w) { if (!u) { u = ++tot, fa[u] = f, val[u] = w, num[u] = sum[u] = 1; Splay(u); return; } if (val[u] == w) { ++num[u], ++sum[u]; Splay(u); return; } Ins(ch[u][val[u] \u003c w], u, w); } void Ins(int w) { Ins(rt, 0, w); } void Find(int u, int w) { if (val[u] == w) { Splay(u); return; } Find(ch[u][val[u] \u003c w], w); } void Merge(int x, int y) { if (!x) { rt = y, fa[y] = 0; return; } //** rt = x, fa[x] = 0; while (ch[x][1]) x = ch[x][1]; Splay(x); ch[rt][1] = y, fa[y] = rt, upd(rt); //** } void Del(int w) { Find(rt, w); if (num[rt] \u003e 1) --num[rt]; else Merge(ch[rt][0], ch[rt][1]); } int rk(int w) { int u = rt, res = 0; while (u) { if (val[u] == w) return res + sum[ch[u][0]] + 1; else if (val[u] \u003c w) res += sum[ch[u][0]] + num[u], u = ch[u][1]; else u = ch[u][0]; } return res + 1; } int kth(int res) { int u = rt; while (res) { if (sum[ch[u][0]] \u003c res and sum[ch[u][0]] + num[u] \u003e= res) return val[u]; else if (res \u003c= sum[ch[u][0]]) u = ch[u][0]; else res -= sum[ch[u][0]] + num[u], u = ch[u][1]; } return val[u]; } int pre(int w) { Ins(w); int u = ch[rt][0]; while (ch[u][1]) u = ch[u][1]; Del(w); //** return val[u]; } int suf(int w) { Ins(w); int u = ch[rt][1]; while (ch[u][0]) u = ch[u][0]; Del(w); //** return val[u]; } } S; int n; int main() { cin \u003e\u003e n; for (int i = 1, ty, x; i \u003c= n; ++i) { scanf(\"%d%d\", \u0026ty, \u0026x); if (ty == 1) S.Ins(x); if (ty == 2) S.Del(x); if (ty == 3) printf(\"%d\\n\", S.rk(x)); if (ty == 4) printf(\"%d\\n\", S.kth(x)); if (ty == 5) printf(\"%d\\n\", S.pre(x)); if (ty == 6) printf(\"%d\\n\", S.suf(x)); } return 0; } ","date":"2021-03-31","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/:4:0","tags":["OI","学习笔记","数据结构","平衡树","Splay"],"title":"[学习笔记]Splay","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0splay/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 有 $n$ 个车站，从 $1$ 到 $n$ 编号，车站 $i$ 初始有 $a_i$ 个人。 在每个小时结束的前几分钟，车站 $i$ 会新增 $b_i$ 个人。 玩家有无限辆容量为 $k$ 的火车。 玩家在每个小时的中间 (也就是 $\\mathrm{30min, 1h30min, 2h30min…}$) 可以让任意辆火车从始发站 $1$ 按照 $1, 2, 3, \\cdots n$ 的顺序驶向终点站 $n$。 ($x$ 辆同时发动的火车可看做一辆容量 $x \\times k$ 的火车。) 每辆火车会尽可能的载上它经过站点的所有人。也就是说，如果一辆火车搭载了站点 $i$ 的人，则在它经过后，站点 $1 \\sim i - 1$ 的人数都为 $0$。 若某个时刻站点 $i$ 的人数超过 $c_i$，则该站台会发生暴乱。 求在保证 $t$ 个小时内所有站台都不发生暴乱情况下，玩家派出的火车的最小数量。 ","date":"2021-03-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1007emini-metro/:1:0","tags":["OI","解题报告","DP","CodeForces"],"title":"[解题报告][CF1007E]Mini Metro","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1007emini-metro/"},{"categories":["OI","解题报告"],"content":"Solution 考虑从前往后把站台一个个加进来，在此基础上进行 DP。 为了方便描述，我们在第 $n + 1$ 位加上一个人数无限多的站台，并设 $sa$ 为 $a$ 的前缀和，$sb$ 为 $b$ 的前缀和。 设 DP 状态 $f_{i, s, z}$ 表示考虑到前 $i$ 个站台，初始人数为 $z \\cdot a_i (z \\in { 0, 1 })$，能撑 $s$ 轮，且每辆火车都载满 $k$ 个人的最小代价。若无解则为 $\\infty$。 $g_{i, s, z}$ 表示在上述条件下满足第 $s$ 轮后站台 $1 \\sim i - 1$ 的人数都为 $0$ 的最小代价。若无解则为 $\\infty$。 「载满 $k$ 个人」就是保证进行的所有操作不会影响到第 $i + 1$ 个站台；而 $g_{i, s, z}$ 就相当于在满足 $f_{i, s, z}$ 的情况下多派几辆火车，使得接下来能够直接访问站台 $i$。 易得初始值 $f_{0, 0, 1} = 0$，答案为 $f_{n, z, 1}$。 转移的话我们分类讨论在第 $s$ 小时之前是否到过站台 $i$。 在 $s$ 小时之前未到过站台 $i$。 那么此时我们需要保证在 $s$ 小时内站台 $i$ 不会发生暴乱，并且 $f_{i - 1, s, z} \\not = \\infty$。 有转移 $$ \\begin{aligned} f_{i, s, z} \u0026\\leftarrow f_{i - 1, s, z} \\\\ g_{i, s, z} \u0026\\leftarrow num = \\left\\lceil \\frac{z \\cdot sa_{i - 1} + s \\cdot sb_{i - 1}}{k} \\right\\rceil \\end{aligned} $$ 而对于 $g$ 的转移还有条件 $k \\cdot num \\le z \\cdot sa_i + s \\cdot b_i$，即保证不会影响到站台 $i + 1$。 上一次在 $r$ 小时到达了站台 $i$。 那么我们的转移可以分为三个阶段。 在 $r$ 小时到达了站台 $i$。 在 $r$ 小时再额外派 $x$ 辆火车，使得站台 $i$ 在接下来 $s - r$ 个小时不会发生暴乱。 维护前 $i - 1$ 个站台在 $s - r$ 个小时内不会发生暴乱，且前 $i - 1$ 个站台的初始人数都为 $0$。 对于第 1 阶段, 因为到达了站台 $i$，所以前 $i - 1$ 的站台的人数一定都为 $0$，因此代价即为 $g_{i, r, z}$。 对于第 2 阶段，我们可以得到此时站台 $i$ 的人数 $m = z \\cdot sa_i + r \\cdot sb_i - k \\cdot g_{i, r, z}$，因此可以得到 $x = \\max(0, \\left\\lceil \\frac{m + (s - r) \\cdot b_i - c_i}{k} \\right\\rceil)$。此时还要判断一下若 $k \\cdot x \u003e m$，则不能进行转移。 对于第 3 阶段，我们需要对 $f, g$ 分别讨论 对于 $f$，只需要保证这前 $i - 1$ 个站台在初始值为 $0$ 的情况下在 $s - r$ 个小时内不发生暴乱，即为 $f_{i - 1, s - r, 0}$。 对于 $g$，我们在保证不发生暴乱的前提下需要把前 $i - 1$ 个站台清空，则代价为 $num = \\left\\lceil \\frac{(s - r) \\cdot sb_{i - 1}}{k} \\right\\rceil$。转移的条件与第一种情况中 $g$ 的转移类似， 即 $f_{i - 1, s - r, 0} \\not = \\infty$ 且 $k \\cdot num \\le m - k \\cdot x + (s - r) \\cdot b_i$。 所以总的转移即为 $$ \\begin{aligned} f_{i, s, z} \u0026\\leftarrow g_{i, r, z} + x + f_{i - 1, s - r, 0} \\\\ g_{i, s, z} \u0026\\leftarrow g_{i, r, z} + x + \\left\\lceil \\frac{(s - r) \\cdot sb_{i - 1}}{k} \\right\\rceil \\end{aligned} $$ 总时间复杂度为 $O(nt^2)$。 注意要开 $long\\ long$。 ","date":"2021-03-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1007emini-metro/:2:0","tags":["OI","解题报告","DP","CodeForces"],"title":"[解题报告][CF1007E]Mini Metro","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1007emini-metro/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; typedef long long ll; const int _ = 200 + 7; const ll inf = 1e15; int n, T, K; ll a[_], b[_], c[_], sa[_], sb[_], d[_][_][2], g[_][_][2]; ll Ceil(ll x, ll y) { return x % y ? x / y + 1 : x / y; } void upd(ll \u0026x, ll y) { x = min(x, y); } int main() { cin \u003e\u003e n \u003e\u003e T \u003e\u003e K; for (int i = 1; i \u003c= n; ++i) { cin \u003e\u003e a[i] \u003e\u003e b[i] \u003e\u003e c[i]; sa[i] = sa[i - 1] + a[i]; sb[i] = sb[i - 1] + b[i]; } a[++n] = inf, c[n] = inf; sa[n] = sa[n - 1] + a[n]; for (int p = 1; p \u003c= n; ++p) for (int s = 0; s \u003c= T; ++s) for (int z = 0; z \u003c= 1; ++z) d[p][s][z] = g[p][s][z] = inf; for (int p = 1; p \u003c= n; ++p) for (int s = 0; s \u003c= T; ++s) for (int z = 0; z \u003c= 1; ++z) { if (z * a[p] + s * b[p] \u003c= c[p] and d[p - 1][s][z] != inf) { upd(d[p][s][z], d[p - 1][s][z]); ll num = Ceil(z * sa[p - 1] + s * sb[p - 1], K); if (num * K \u003c= z * sa[p] + s * sb[p]) upd(g[p][s][z], num); } for (int r = 0; r \u003c s; ++r) if (g[p][r][z] != inf and d[p - 1][s - r][0] != inf) { ll m = z * sa[p] + r * sb[p] - K * g[p][r][z]; ll x = Ceil(max(0ll, m + (s - r) * b[p] - c[p]), K); if (K * x \u003c= m) { upd(d[p][s][z], g[p][r][z] + x + d[p - 1][s - r][0]); ll num = Ceil((s - r) * sb[p - 1], K); if (num * K \u003c= m - K * x + (s - r) * sb[p]) upd(g[p][s][z], g[p][r][z] + x + num); } } } cout \u003c\u003c d[n][T][1] \u003c\u003c endl; return 0; } ","date":"2021-03-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1007emini-metro/:3:0","tags":["OI","解题报告","DP","CodeForces"],"title":"[解题报告][CF1007E]Mini Metro","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1007emini-metro/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 定义一个二元运算 $\\oplus$ 表示对每一个二进制位分别进行不同的位运算 (或 / 与 / 异或). 给定一个 $n$ 个点 $m$ 条边的无向图, 每条边有一个 $[0, 2^w)$ 范围内的边权. 求这张图在 $\\oplus$ 运算下的最大生成树权值. $ 1 \\le n \\le 70, 1 \\le m \\le 5000, 1 \\le w \\le 12 $. ","date":"2021-03-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Athupc2019%E6%89%BE%E6%A0%91/:1:0","tags":["OI","解题报告","计数","生成树","矩阵树定理","多项式","FWT","THUPC","THUPC2019"],"title":"[解题报告][THUPC2019]找树","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Athupc2019%E6%89%BE%E6%A0%91/"},{"categories":["OI","解题报告"],"content":"Solution 直接想最大值完全没有思路. 但可以注意到这个 $w$ 很小, 所以我们可以考虑枚举权值, 然后计算该权值的生成树数量. 生成树数量可以用矩阵树定理求; 特定权值的生成树数量在矩阵里套个生成树就行了. 如果边权之间的运算是普通的 $+$ 的话, 直接把矩阵内的数乘换成多项式乘法就行了. 而这里边权之间的运算是一个二进制运算, 所以我们可以考虑用 FWT. 但一般使用 FWT 时, 所有二进制位的运算类型都是相同的, 而这里每个二进制位都有一个独立的运算类型. 但实际上 FWT 也可以处理这种情况, 只要在 FWT / IFWT 时对于每一个二进制位按照它对应的运算进行对应的操作即可. (为什么是对的我也不会证, 姑且就当个结论来记吧.) 所以我们现在得到一个做法: 把矩阵中的数换成生成函数, 然后在生成函数之间做 FWT, 最后查看每一个权值的生成树数量, 取最大的生成树数量非 0 的权值即为答案. 但求行列式 (高斯消元) 时如果直接把所有数乘都换成 FWT, 复杂度是 $O(n^3 2^w w) \\approx 10^{10}$, 显然过不了. NTT 中一个常见的优化思路是把多项式运算换成点值运算. 这里对于 FWT, 我们也同样可以使用\"点值\" (也就是 FWT 后得到的数组) 运算来优化. 由于 FWT 不用像 NTT 那样考虑循环卷积的问题, 所以我们可以先一次性把所有多项式先 FWT 一遍, 求完行列式后再 IFWT 回来即可. 并且由于点值运算中各个点值之间是相互独立的, 所以我们可以每次让矩阵中所有多项式的同一个点值构成一个新的矩阵, 对这个矩阵单独求行列式, 最后把每个点值求出的行列式的值拼起来, 最后再 IFWT 回去就行了. 时间复杂度 $O(n^3 w^m) \\approx 10^9$. 看着非常不能过, 但它就是能过… 托腮课件里说可以用一个较小的模数来优化常数, 但我直接带 $10^9 + 7$ 它也没 T… ","date":"2021-03-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Athupc2019%E6%89%BE%E6%A0%91/:2:0","tags":["OI","解题报告","计数","生成树","矩阵树定理","多项式","FWT","THUPC","THUPC2019"],"title":"[解题报告][THUPC2019]找树","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Athupc2019%E6%89%BE%E6%A0%91/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = 70 + 7; const int __ = (1 \u003c\u003c 12) + 7; const int mod = 1e9 + 7, inv2 = 500000004; int n, m, W, tot, a[_][_], f[_][_][__], g[__]; char S[_]; void FWT(int *f, bool ty) { for (int len = 2, t = 0; len \u003c= tot; len \u003c\u003c= 1, ++t) { int gap = len \u003e\u003e 1; for (int i = 0; i \u003c tot; i += len) for (int j = 0; j \u003c gap; ++j) { int w[2] = { f[i + j], f[i + j + gap] }; if (S[t] == '\u0026') f[i + j] = (0ll + w[0] + (ty ? mod - w[1] : w[1])) % mod; else if (S[t] == '|') f[i + j + gap] = (0ll + w[1] + (ty ? mod - w[0] : w[0])) % mod; else if (!ty) f[i + j] = (w[0] + w[1]) % mod, f[i + j + gap] = (w[0] - w[1] + mod) % mod; else f[i + j] = 1ll * (w[0] + w[1]) * inv2 % mod, f[i + j + gap] = 1ll * (w[0] - w[1] + mod) * inv2 % mod; } } } int Pw(int a, int p) { int res = 1; while (p) { if (p \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; p \u003e\u003e= 1; } return res; } int Det() { int res = 1, t = 0; for (int i = 1; i \u003c n; ++i) { if (!a[i][i]) { for (int j = i + 1; j \u003c n; ++j) if (a[j][i]) { for (int k = i; k \u003c n; ++k) swap(a[j][k], a[i][k]); break; } t ^= 1; } if (!a[i][i]) return 0; int Inv = Pw(a[i][i], mod - 2); res = 1ll * res * a[i][i] % mod; for (int j = i + 1; j \u003c n; ++j) { int tmp = 1ll * a[j][i] * Inv % mod; for (int k = i; k \u003c n; ++k) a[j][k] = (a[j][k] - 1ll * a[i][k] * tmp % mod + mod) % mod; } } return t ? (mod - res) % mod : res; } int main() { scanf(\"%d%d%s\", \u0026n, \u0026m, S), W = strlen(S), tot = 1 \u003c\u003c W; for (int i = 1, x, y, w; i \u003c= m; ++i) { scanf(\"%d%d%d\", \u0026x, \u0026y, \u0026w); ++f[x][x][w], ++f[y][y][w]; --f[x][y][w], --f[y][x][w]; } for (int i = 1; i \u003c n; ++i) for (int j = 1; j \u003c n; ++j) { for (int w = 0; w \u003c tot; ++w) f[i][j][w] = (f[i][j][w] + mod) % mod; FWT(f[i][j], 0); } for (int w = 0; w \u003c tot; ++w) { for (int i = 1; i \u003c n; ++i) for (int j = 1; j \u003c n; ++j) a[i][j] = f[i][j][w]; g[w] = Det(); } FWT(g, 1); for (int w = tot - 1; ~w; --w) if (g[w]) { printf(\"%d\\n\", w); exit(0); } puts(\"-1\"); return 0; } ","date":"2021-03-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Athupc2019%E6%89%BE%E6%A0%91/:3:0","tags":["OI","解题报告","计数","生成树","矩阵树定理","多项式","FWT","THUPC","THUPC2019"],"title":"[解题报告][THUPC2019]找树","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Athupc2019%E6%89%BE%E6%A0%91/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 给定一棵节点数为 $n$ 的树, 以及根节点 $X$. 有 $Q$ 次询问, 每次给定一个点集 $S$, 求从 $X$ 开始随机游走 (每次随机走向与 $u$ 相连的一个点), 经过 $S$ 内所有点至少一次的期望步数. $n \\le 18, Q \\le 5000$. ","date":"2021-03-11","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Apkuwc2018%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/:1:0","tags":["OI","解题报告","消元","树上高斯消元","概率与期望","计数","Min-Max容斥","PKUWC","PKUWC2018"],"title":"[解题报告][PKUWC2018]随机游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Apkuwc2018%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"Solution 这题可以看做一种套路的模板, 即:「在树 (特殊图) 上随机游走, 第一次到达某个点集的期望步数」. 主要思路是消元. 这种套路求的是 「第一次到达点集的期望步数」, 而这题求的是「到点集内每个节点至少一次」, 相当于一个是到达该点集的时间最小值, 一个是到达该点集的时间最大值, 所以我们可以先套个 $\\min-\\max$ 容斥. 即 $$ \\max(S) = \\sum_{T \\subseteq S} (-1)^{|T| - 1} \\min(T) $$ 所以现在我们只需要求第一次到达某个点集的期望步数, 再做个高维前缀和就行了. 然后就可以按照套路来做了. 设当前点集为 $S$, $f_{u, S}$ 为: 从 $u$ 开始随机游走, 第一次到达 $S$ 的期望步数. 简写为 $f_u$. 然后就有式子 (设 $E$ 为边集) $$ f_{u} = \\frac{1}{deg_u} \\sum_{(u, v) \\in E} (f_{v} + 1) $$ 把 $f_{1 \\sim n}$ 看做 $n$ 个变量, 对每个 $u$ 可以列出一个式子, 就可以直接高斯消元了, 总复杂度为 $O(2^n n^3)$. 但考虑到树的特殊结构, 我们可以将消元的复杂度做到更优. 考虑节点 $u$, 在对 $u$ 列出的式子中, 除了 $f_{fa_u}$ 以外, 其余的变量都在 $u$ 的子树内. 所以我们可以考虑先把 $u$ 的子树内 (不包括 $u$) 的变量都化为 $af_{u} + b$ 的形式, 然后再带入 $u$ 的式子内, 就可以把 $f_u$ 化为 $af_{fa_u} + b$ 的形式. 然后对 $fa_u$ 再进行同样的过程, 一直往上消元, 最终就可以得到 $f_X$ 的值了. 然后再 $O(n 2^n)$ 求一次高维前缀和, 每次 $O(1)$ 回答即可. 实际上这题的改成 $X$ 不固定 (即对于每个询问给一个不同的 $X$) 也可以做. 只需要在算出上面的 $f_X$ 后, 把它往子树中代入, 然后就可以对每个 $u$ 都求出 $f_u$ 了. 总复杂度为 $O(2^nn + Q)$. ","date":"2021-03-11","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Apkuwc2018%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/:2:0","tags":["OI","解题报告","消元","树上高斯消元","概率与期望","计数","Min-Max容斥","PKUWC","PKUWC2018"],"title":"[解题报告][PKUWC2018]随机游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Apkuwc2018%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ciostream\u003e#include \u003cvector\u003e #define pb push_back #define sz(x) (int)(x).size() #define mkp make_pair #define fi first #define se second using namespace std; const int _ = 18 + 7; const int __ = (1 \u003c\u003c 18) + 7; const int mod = 998244353; int n, Q, X, g[__]; pair\u003cint, int\u003e f[_]; vector\u003cint\u003e to[_]; int Pw(int a, int p) { int res = 1; while (p) { if (p \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; p \u003e\u003e= 1; } return res; } int popcount(int x) { int cnt = 0; for (int i = 0; i \u003c n; ++i) cnt += x \u003e\u003e i \u0026 1; return cnt; } void Dfs(int u, int fa, int s) { f[u] = mkp(0, 0); if (s \u003e\u003e (u - 1) \u0026 1) return; for (int v: to[u]) { if (v == fa) continue; Dfs(v, u, s); f[u].fi = (f[u].fi + f[v].fi) % mod; f[u].se = (f[u].se + f[v].se) % mod; } if (u != X) { int Inv = Pw(sz(to[u]) - f[u].fi + mod, mod - 2); f[u].fi = Inv; f[u].se = 1ll * (f[u].se + sz(to[u])) * Inv % mod; } else { int Inv = Pw(sz(to[u]), mod - 2); f[u].fi = 1ll * f[u].fi * Inv % mod; f[u].se = 1ll * (f[u].se + sz(to[u])) * Inv % mod; } } int main() { cin \u003e\u003e n \u003e\u003e Q \u003e\u003e X; for (int i = 1, x, y; i \u003c n; ++i) { cin \u003e\u003e x \u003e\u003e y; to[x].pb(y), to[y].pb(x); } for (int s = 1; s \u003c 1 \u003c\u003c n; ++s) { Dfs(X, 0, s); int tmp = 1ll * f[X].se * Pw(1 - f[X].fi + mod, mod - 2) % mod; g[s] = (popcount(s) \u0026 1) ? tmp : (mod - tmp) % mod; } for (int i = 0; i \u003c n; ++i) for (int s = 0; s \u003c 1 \u003c\u003c n; ++s) if (s \u003e\u003e i \u0026 1) g[s] = (g[s] + g[s ^ (1 \u003c\u003c i)]) % mod; for (int t = 1, K, s; t \u003c= Q; ++t) { cin \u003e\u003e K, s = 0; for (int i = 1, x; i \u003c= K; ++i) cin \u003e\u003e x, s |= 1 \u003c\u003c (x - 1); cout \u003c\u003c g[s] \u003c\u003c endl; } return 0; } ","date":"2021-03-11","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Apkuwc2018%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/:3:0","tags":["OI","解题报告","消元","树上高斯消元","概率与期望","计数","Min-Max容斥","PKUWC","PKUWC2018"],"title":"[解题报告][PKUWC2018]随机游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Apkuwc2018%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 定义一个字符集为 ${0, 1, 2, \\cdots, 9}$ 的字符串 $S$ 的价值为：$S$ 的所有无前缀0的且所代表的数字属于区间 $[L, R]$ 内的子串 $T$ 的个数。 给定 $S$ 的长度 $n$ 以及区间 $[L, R]$，求价值最大且字典序最小的字符串 $S$。 $1 \\le L \\le R \\le 10^{800}, 1 \\le n \\ le 2000$。 ","date":"2021-03-06","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1110hmodest-substrings/:1:0","tags":["OI","解题报告","字符串","AC自动机","CodeForces"],"title":"[解题报告][CF1110H]Modest Substrings","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1110hmodest-substrings/"},{"categories":["OI","解题报告"],"content":"Solution 首先考虑若 $R - L$ 很小的时候怎么做。 我们可以把 $[L, R]$ 之间的所有数字插入 Trie 树中，并建立 AC 自动机。 然后设 DP 状态 $f[i][u]$ 表示当前填到 $S$ 的第 $i$ 位，且在 AC 自动机上匹配到节点 $u$ 时的最大价值。 对于构造方案，我们可以对每个 DP 状态找它的前缀。 具体来说，设 $maxf[i][u]$ 表示从 $f[i][u]$ 状态开始转移，最终能够得到的最大值。 然后我们从前往后构造，假设当前的状态为 $(i, u)$，那么我们取最小的满足 $f[i + 1][ch[u][c]]$ 是从 $f[i, u]$ 转移过去的 且 $maxf[i + 1][ch[u][c]] = \\mathrm{ans}$ 且 的 $c$ 进行转移即可。 现在进一步考虑 $R - L$ 更大的时候怎么做。 我们会发现，当 $[L, R]$ 中的数很多时，Trie 树上会出现很多子树是“满十叉树”的节点。 对于这些节点，只要从它开始往下走一定距离，就一定会得到一些贡献，与走的方向（也就是在 $S$ 中所填的数）无关。 那么我们可以考虑在一到达这些点的时候就先把在它子树中能得到的贡献算进答案中，然后就不需要遍历它的子树了。这样就减少了 Trie 树中的节点数。 于是我们设 $g[u][j]$ 表示从 Trie 树上的节点 $u$ 开始，走 $j$ 步后一定能得到的价值。 现在我们考虑该怎么设这个 $g$ 数组。 我们按照「 $L$ 和 $R$ 的位数是否相同」进行分类讨论。 ","date":"2021-03-06","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1110hmodest-substrings/:2:0","tags":["OI","解题报告","字符串","AC自动机","CodeForces"],"title":"[解题报告][CF1110H]Modest Substrings","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1110hmodest-substrings/"},{"categories":["OI","解题报告"],"content":"First. $L$ 和 $R$ 位数不同 这时，对于位数在 $[|L| + 1, |R| - 1]$ 中的所有数，只要没有前导0并且走了 $j$ 步后，就一定能得到一个位数为 $j$ 的数。 那么，我们对节点 1（也就是根节点）的所有0儿子 $v = ch[1][1 \\sim 9]$，将 $g[v][|L| \\sim |R| - 2]$ 设为 1。（因为从根节点到 $v$ 就已经填了一位了，所以剩下就只用填 $|L| \\sim |R| - 2$ 位。） 然后对于位数为 $|L|$ 的所有数，只要它的字典序大于等于 $L$，则它可以贡献到答案中。 在 Trie 树上插入 $L$ 的过程中，我们设当前插入到 $L_i = c$，且到达 Trie 树上的节点 $u$，那么我们将 $g[ch[u][c + 1 \\sim 9]][|L| - i]$ 设为 1。 然后设插入 $L$ 后最终到达的节点为 $x$，将 $g[x][0]$ 设为 1。 对于位数为 $|R|$ 的所有数，做类似操作就行了。 ","date":"2021-03-06","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1110hmodest-substrings/:2:1","tags":["OI","解题报告","字符串","AC自动机","CodeForces"],"title":"[解题报告][CF1110H]Modest Substrings","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1110hmodest-substrings/"},{"categories":["OI","解题报告"],"content":"Second. $L$ 和 $R$ 的位数相同 我们设 $i$ 为 $L, R$ 第一次不相等的位置，设它在 Trie 树上对应节点 $u$，将 $g[ch[u][L[i] + 1 \\sim R[i] - 1]][|L| - i]$ 设为 1。 剩下的位置与第一种情况中位数为 $|L|$ 的数类似。 处理完 $g$ 数组后，在找 $fail$ 的时候把 $g[fail[u]]$ 也加到 $g[u]$ 上。 $f$ 的转移即为 $f[i][u] + \\sum_{j = 0}^{n - i - 1} g[ch[u][c]][j] \\rightarrow f[i + 1][ch[u][c]]$。可以前缀和优化一下。 时间复杂度为 $O(10|R|n) \\approx 1.6 \\times 10^7$。 ","date":"2021-03-06","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1110hmodest-substrings/:2:2","tags":["OI","解题报告","字符串","AC自动机","CodeForces"],"title":"[解题报告][CF1110H]Modest Substrings","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1110hmodest-substrings/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e using namespace std; const int _ = 2e3 + 7; const int __ = 2e4 + 7; typedef long long ll; int n, l1, l2, ch[__][10], fail[__], tot = 1; ll f[_][__], maxf[_][__], g[__][_]; char L[_], R[_], S[_]; queue\u003cint\u003e q; void Ins(char S[], int ty) { int u = 1, len = strlen(S + 1); bool flag = l1 == l2; for (int i = 1; i \u003c= len; ++i) { int c = S[i] - '0'; if (!ch[u][c]) ch[u][c] = ++tot; if (!ty) { int lim = flag ? R[i] - '0' - 1 : 9; for (int j = c + 1; j \u003c= lim; ++j) { if (!ch[u][j]) ch[u][j] = ++tot; ++g[ch[u][j]][len - i]; } } else { int lim = flag ? 9 : 0; for (int j = c - 1; j \u003e= lim; --j) { if (!j and i == 1) continue; if (!ch[u][j]) ch[u][j] = ++tot; ++g[ch[u][j]][len - i]; } } u = ch[u][c]; if (L[i] != R[i]) flag = 0; } if (!ty or !flag) ++g[u][0]; } void GetFail() { for (int i = 0; i \u003c 10; ++i) ch[0][i] = 1; q.push(1); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i \u003c 10; ++i) if (ch[u][i]) fail[ch[u][i]] = ch[fail[u]][i], q.push(ch[u][i]); else ch[u][i] = ch[fail[u]][i]; for (int i = 0; i \u003c= n; ++i) g[u][i] += g[fail[u]][i]; } for (int u = 1; u \u003c= tot; ++u) for (int i = 1; i \u003c= n; ++i) g[u][i] += g[u][i - 1]; } int main() { scanf(\"%s%s%d\", L + 1, R + 1, \u0026n); l1 = strlen(L + 1), l2 = strlen(R + 1); Ins(L, 0), Ins(R, 1); for (int i = 1; i \u003c 10; ++i) { if (!ch[1][i]) ch[1][i] = ++tot; for (int j = l1; j \u003c l2 - 1; ++j) ++g[ch[1][i]][j]; } GetFail(); memset(f, -0x3f, sizeof f); f[0][1] = 0; for (int i = 0; i \u003c n; ++i) { for (int j = 1; j \u003c= tot; ++j) { if (f[i][j] \u003c 0) continue; for (int k = 0; k \u003c 10; ++k) f[i + 1][ch[j][k]] = max(f[i + 1][ch[j][k]], f[i][j] + g[ch[j][k]][n - i - 1]); } } ll ans = 0; for (int j = 1; j \u003c= tot; ++j) ans = max(ans, f[n][j]), maxf[n][j] = f[n][j]; for (int i = n - 1; ~i; --i) for (int j = 1; j \u003c= tot; ++j) for (int k = 0; k \u003c 10; ++k) if (f[i + 1][ch[j][k]] == f[i][j] + g[ch[j][k]][n - i - 1]) maxf[i][j] = max(maxf[i][j], maxf[i + 1][ch[j][k]]); assert(maxf[0][1] == ans); int u = 1; for (int i = 0; i \u003c n; ++i) for (int k = 0; k \u003c 10; ++k) if (maxf[i + 1][ch[u][k]] == ans and f[i + 1][ch[u][k]] == f[i][u] + g[ch[u][k]][n - i - 1]) { S[i + 1] = k + '0', u = ch[u][k]; break; } printf(\"%lld\\n%s\\n\", ans, S + 1); return 0; } ","date":"2021-03-06","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1110hmodest-substrings/:3:0","tags":["OI","解题报告","字符串","AC自动机","CodeForces"],"title":"[解题报告][CF1110H]Modest Substrings","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Acf1110hmodest-substrings/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 $0 \\le k \u003c n \u003c 998244353, 1 \\le m \\le n$。 ","date":"2021-03-04","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anflsoj5292020%E5%85%AD%E6%A0%A1%E8%81%94%E5%90%88%E8%AE%AD%E7%BB%83%E7%9C%81%E9%80%892%E6%89%93%E5%8D%A1%E4%BB%BB%E5%8A%A1/:1:0","tags":["OI","解题报告","计数","生成函数","循环卷积","FFT","NFLSOJ"],"title":"[解题报告][NFLSOJ529][2020六校联合训练省选2]打卡任务","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anflsoj5292020%E5%85%AD%E6%A0%A1%E8%81%94%E5%90%88%E8%AE%AD%E7%BB%83%E7%9C%81%E9%80%892%E6%89%93%E5%8D%A1%E4%BB%BB%E5%8A%A1/"},{"categories":["OI","解题报告"],"content":"Solution 先把答案用二元生成函数的形式表示出来，即 $$ \\mathrm{ans} = [y^m][x^k] \\prod_{i = 0}^{n - 1} (1 - x^iy) \\pmod{(x^n - 1)} $$ （$ \\mod{(x^n - 1)} $即为循环卷积。） 然后由于 $x$ 这一维是循环卷积，所以我们考虑引入单位根，用 DFT、IDFT 的形式来表示答案。 回顾一下 IDFT 的过程。设 $A$ 为多项式，向量 $B$ 为 $A$ 在 $\\omega_{n}^{0 \\sim n - 1}$ 处的点集，则有 $$ \\frac{1}{n} \\begin{Bmatrix} 1 \u0026 1 \u0026 1 \u0026 \\cdots \u0026 1 \\\\ 1 \u0026 \\omega_{n}^{1} \u0026 \\omega_{n}^{2} \u0026 \\cdots \u0026 \\omega_{n}^{n - 1} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 1 \u0026 \\omega_{n}^{k} \u0026 \\omega_{n}^{2k} \u0026 \\cdots \u0026 \\omega_{n}^{(n - 1)k} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 1 \u0026 \\omega_{n}^{n - 1} \u0026 \\omega_{n}^{2(n-1)} \u0026 \\cdots \u0026 \\omega_{n}^{(n - 1)(n - 1)} \\\\ \\end{Bmatrix} B = A $$ 现在 $B$ 是容易用单位根表示的，那么 $A$ 的 $k$ 次项系数就也可以用单位根来表示，即 $$ \\begin{aligned} \\mathrm{ans} \u0026= [y^m][x^k] \\prod_{i = 0}^{n - 1} (1 - x^iy) \\pmod{(x^n - 1)} \\\\ \u0026= [y^m]\\frac{1}{n}\\sum_{j = 0}^{n - 1} \\omega_{n}^{-jk} \\prod_{i=0}^{n-1}(1+\\omega_{n}^{ij}y) \\end{aligned} $$ 后面 $\\prod_{i=0}^{n-1}(1+\\omega_{n}^{ij}y)$ 这就是将 $n$ 次单位根中的若干个的若干次方乘了起来。那么我们可以考虑直接找出是哪几个单位根被算进了贡献里，然后将原来的式子用这几个单位根的若干次方表示，这样相当于减少了要考虑的因素。 具体来说，设 $d = \\gcd(n, j)$，则被算进贡献里的单位根就只有 $\\omega_{n}^{0}, \\omega_{n}^{d}, \\omega_{n}^{2d}, \\cdots, \\omega_{n}^{n - d}$ 这 $\\frac{n}{d}$ 项，并且每一项都贡献了 $d$ 次方。 即 $\\prod_{i=0}^{n-1}(1+\\omega_{n}^{ij}y) = \\prod_{i=0}^{\\frac{n}{d} - 1} (1 + \\omega_{\\frac{n}{d}}^{i}y)^{d}$。 我们发现转化后的式子至于 $d$ 有关，所以我们可以考虑先枚举 $d$，然后再莫比乌斯反演一下，即 $$ \\begin{aligned} \\mathrm{ans} \u0026= [y^m]\\frac{1}{n}\\sum_{j = 0}^{n - 1} \\omega_{n}^{-jk} \\prod_{i=0}^{n-1}(1+\\omega_{n}^{ij}y) \\\\ \u0026= [y^m]\\frac{1}{n}\\sum_{j = 0}^{n - 1} \\omega_{n}^{-jk} \\prod_{i=0}^{\\frac{n}{d} - 1} (1 + \\omega_{\\frac{n}{d}}^{i}y)^{d} \\\\ \u0026= [y^m]\\frac{1}{n} \\sum_{d | n} \\prod_{i=0}^{\\frac{n}{d} - 1} (1 + \\omega_{\\frac{n}{d}}^{i}y)^{d} \\sum_{j = 0}^{n - 1} [\\gcd(n, j) == d]\\omega_{n}^{-jk} \\\\ \u0026= [y^m]\\frac{1}{n} \\sum_{d | n} \\prod_{i=0}^{\\frac{n}{d} - 1} (1 + \\omega_{\\frac{n}{d}}^{i}y)^{d} \\sum_{j = 0}^{\\frac{n}{d} - 1} [\\gcd(\\frac{n}{d}, j) == 1]\\omega_{n}^{-jk} \\\\ \\end{aligned} $$ 然后我们把后面 $\\sum_{j = 0}^{\\frac{n}{d} - 1} [\\gcd(\\frac{n}{d}, j) == 1]\\omega_{n}^{-jk}$ 单独拿出来莫比乌斯反演一下，可以得到 $$ \\sum_{j = 0}^{\\frac{n}{d} - 1} [\\gcd(\\frac{n}{d}, j) == 1]\\omega_{n}^{-jk} = \\sum_{e | \\frac{n}{d}} \\mu(e) \\sum_{j = 0}^{\\frac{n}{de} - 1} \\omega_{\\frac{n}{de}}^{-jk} $$ 然后发现 $\\sum_{j = 0}^{\\frac{n}{de} - 1} \\omega_{\\frac{n}{de}}^{-jk}$ 这一坨式子长的是个单位根反演的形式，所以我们可以反向使用单位根反演，即 $$ \\begin{aligned} \\sum_{j = 0}^{\\frac{n}{d} - 1} [\\gcd(\\frac{n}{d}, j) == 1]\\omega_{n}^{-jk} \u0026= \\sum_{e | \\frac{n}{d}} \\mu(e) \\sum_{j = 0}^{\\frac{n}{de} - 1} \\omega_{\\frac{n}{de}}^{-jk} \\\\ \u0026= \\sum_{e | \\frac{n}{d}} \\mu(e) \\sum_{j = 0}^{\\frac{n}{de} - 1} \\omega_{\\frac{n}{de}}^{jk} \\\\ \u0026= \\sum_{e | \\frac{n}{d}} \\mu(e) \\frac{n}{de} \\left[\\frac{n}{de} | k\\right] \\\\ \\end{aligned} $$ 所以答案计算式可以化为 $$ \\begin{aligned} \\mathrm{ans} \u0026= [y^m]\\frac{1}{n} \\sum_{d | n} \\prod_{i=0}^{\\frac{n}{d} - 1} (1 + \\omega_{\\frac{n}{d}}^{i}y)^{d} \\sum_{j = 0}^{\\frac{n}{d} - 1} [\\gcd(\\frac{n}{d}, j) == 1]\\omega_{n}^{-jk} \\\\ \u0026= [y^m]\\frac{1}{n} \\sum_{d | n} \\prod_{i=0}^{\\frac{n}{d} - 1} (1 + \\omega_{\\frac{n}{d}}^{i}y)^{d} \\sum_{e | \\frac{n}{d}} \\mu(e) \\frac{n}{de} \\left[\\frac{n}{de} | k\\right] \\\\ \u0026= \\frac{1}{n} \\sum_{d | n} \\left( \\sum_{e | \\frac{n}{d}} \\mu(e) \\frac{n}{de} \\left[\\frac{n}{de} | k\\right] \\right)\\left( [y^m] \\prod_{i=0}^{\\frac{n}{d} - 1} (1 + \\omega_{\\frac{n}{d}}^{i}y)^{d} \\right) \\\\ \\end{aligned} $$ 现在我们就是要求 $\\prod_{i = 0}^{\\frac{n}{d} - 1} (1 + \\omega_{\\frac{n}{d}}^{i}y)^d$ 这个多项式的 $m$ 次项系数。 我们设 $H(y) = \\prod_{i = 0}^{\\frac{n}{d} - 1} (1 + \\omega_{\\frac{n}{d}}^{i}y)$。（和上面那个式子相比少了一个 $d$ 次方。） 由于 $H(y)$ 现在是个乘积的形式，所以方程 $H(y) = 0$ 的解集我们容易得到，即为 $-\\omega_{\\frac{n}{d}}^{0 \\sim \\frac{n}{d} - 1}$。 然后对于两个多项式 $A(x), B(x)$， 若它们的解集相同，并且常数项相等，那么我们可以判定 $A$ 和 $B$ 是相等的。 我们考虑多项式 $A(y) = y^n - 1$，显然它的解集为 $\\omega_{n}^{0 \\sim n - 1}$。 而多项式 $H(y)$ 的解集为 $-\\omega_{\\frac{n}{d}}^{0 \\sim \\frac{n}{d} - 1}$。 那么我们稍微构造一下，就可以得到一个多项式 $B(y) = 1 + (-1)^{\\frac{n}{d} - 1}y^{\\frac{n}{d}}$，它的解集就为 $\\omega_{\\frac{n}{d}}^{0 \\sim \\frac{n}{d} - 1}$。 然后 $H(y)$ 和 $B(y","date":"2021-03-04","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anflsoj5292020%E5%85%AD%E6%A0%A1%E8%81%94%E5%90%88%E8%AE%AD%E7%BB%83%E7%9C%81%E9%80%892%E6%89%93%E5%8D%A1%E4%BB%BB%E5%8A%A1/:2:0","tags":["OI","解题报告","计数","生成函数","循环卷积","FFT","NFLSOJ"],"title":"[解题报告][NFLSOJ529][2020六校联合训练省选2]打卡任务","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anflsoj5292020%E5%85%AD%E6%A0%A1%E8%81%94%E5%90%88%E8%AE%AD%E7%BB%83%E7%9C%81%E9%80%892%E6%89%93%E5%8D%A1%E4%BB%BB%E5%8A%A1/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 5e3 + 7; const int B = 2e5; const int mod = 998244353; int n, m, K; int Bfac[_] = { 1, 638474417, 876712294, 949283602, 187142323, 373341033, 70007868, 501927483, 796024455, 542991096, 45596018, 283287674, 596316874, 417528165, 191166323, 834980587, 914550501, 688948565, 104964765, 393032085, 623627864, 982424362, 446366139, 407729297, 330880448, 428937595, 897706118, 536236563, 860856448, 945501487, 442819817, 57092875, 14554181, 511596111, 142128101, 499710224, 406984354, 372247494, 788080221, 634098066, 833655840, 62174429, 217507999, 826634010, 531854347, 83857087, 391931702, 60435539, 346814021, 201876905, 295201906, 841028503, 595254166, 288961565, 372617820, 788488293, 214785669, 586941976, 798836079, 121559584, 671639287, 905745233, 598047083, 524126609, 332670261, 849315549, 108180821, 330441070, 822163165, 644097424, 597398273, 433824922, 821516475, 558211762, 643537971, 813259672, 980160849, 572408921, 491147937, 662387095, 732727656, 426783046, 336239771, 915978376, 384818512, 244038325, 482374615, 763456553, 670866031, 970700529, 122642896, 307259936, 552245646, 334904481, 700983666, 310517972, 122041708, 158837842, 526576992, 154265204, 160030060, 545120840, 594484528, 125533240, 932427947, 483239722, 888547621, 159892150, 204604906, 953194755, 683879839, 710198568, 40172755, 230420112, 590157392, 712910418, 853172441, 199660950, 89366316, 958564551, 384710263, 193777777, 252902665, 629222215, 513947030, 433880730, 305993854, 844300169, 150494228, 12034969, 844360005, 736620499, 880392466, 621197845, 316234919, 513089677, 600187555, 162637844, 695714167, 580355949, 101492974, 190978288, 622545330, 630593004, 159596479, 959253371, 446760507, 188808028, 19289865, 438270265, 957629942, 411489774, 833415116, 639147854, 1858960, 678615452, 368475610, 97606564, 682682315, 412424033, 34035221, 37308241, 510346646, 745591849, 319020540, 56734233, 74617988, 329751033, 819215905, 147266093, 524027922, 36811456, 183951017, 90677883, 584237732, 31729117, 528753617, 356071602, 259079578, 313473995, 102311167, 365600946, 493073744, 775455687, 826897016, 330331487, 882716777, 345961537, 393771832, 816774574, 8332991, 908086460, 824079438, 223282259, 736669190, 832392662, 649905009, 546421210, 220312447, 872186518, 545208507, 526440874, 564560841, 901016661, 820215494, 594075875, 630254812, 497843223, 451653192, 281875122, 318497156, 281077520, 391564011, 985402237, 281589650, 859275605, 350331071, 110566178, 929486824, 82719024, 300738984, 340522732, 805325367, 223689578, 40359077, 767818091, 906934019, 216541952, 658294019, 303213536, 864118508, 997822898, 348600216, 835484573, 573706739, 878131539, 195969604, 73732226, 756919022, 619535652, 316588744, 178145620, 401222720, 940074300, 885534177, 812496962, 722316264, 348438629, 575985717, 599834990, 213689172, 103783113, 815021282, 860400524, 861687482, 584871249, 676542561, 346129673, 766275603, 579782990, 980836133, 461343290, 169564539, 517235481, 911472795, 54096741, 861375995, 679025032, 733542862, 505796205, 417876813, 695843405, 641311602, 951286622, 604948489, 363266670, 366263604, 168044071, 483981875, 961681722, 335481797, 610724444, 310772360, 380699882, 338568924, 730839588, 429184708, 245641763, 544232708, 20274450, 393495668, 841337447, 563955060, 577941262, 286164023, 435793297, 602069285, 552383730, 550046860, 387930530, 760025067, 885951502, 401178749, 851255079, 19132477, 811438469, 584572864, 72440788, 918098612, 204404247, 720976283, 255229675, 333853788, 977151551, 119288377, 650770098, 947701400, 464060630, 315552202, 744889435, 586537547, 456191643, 333104526, 4390399, 292624291, 117371703, 988378684, 984089998, 234426668, 331300777, 566486504, 911513273, 800612279, 582125752, 283010644, 749562308, 858022481, 684870615, 909030347, 68685886, 708205284, 701025199, 995703398, 863814074, 828484950, 932912293, 464037975, 462924258, 411054570, 449870191, 939830261, 425865548, 39026653","date":"2021-03-04","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anflsoj5292020%E5%85%AD%E6%A0%A1%E8%81%94%E5%90%88%E8%AE%AD%E7%BB%83%E7%9C%81%E9%80%892%E6%89%93%E5%8D%A1%E4%BB%BB%E5%8A%A1/:3:0","tags":["OI","解题报告","计数","生成函数","循环卷积","FFT","NFLSOJ"],"title":"[解题报告][NFLSOJ529][2020六校联合训练省选2]打卡任务","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anflsoj5292020%E5%85%AD%E6%A0%A1%E8%81%94%E5%90%88%E8%AE%AD%E7%BB%83%E7%9C%81%E9%80%892%E6%89%93%E5%8D%A1%E4%BB%BB%E5%8A%A1/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 一个 $N \\times M$ 的网格，每个格子里有一个大写字母。 $Q$ 次询问，每次询问一个子矩阵里的同字符四连通块数量。 $N, M \\le 1000, Q \\le 1000$。 ","date":"2021-03-02","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ausaco21jan-paint-by-letters-p/:1:0","tags":["OI","解题报告","平面图","欧拉公式","USACO"],"title":"[解题报告][USACO21JAN] Paint by Letters P","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ausaco21jan-paint-by-letters-p/"},{"categories":["OI","解题报告"],"content":"Solution 这题应该不算难题，但是那种没见过就写不出来的题…… 心路历程： 一顿乱想 什么都没想出来 自闭 看题解 首先，把每个格子看做一个点，然后在四连通的同字符点之间连边。 显然这样会形成一个平面图。 然后对于平面图连通块数量我们有一个「欧拉公式」。 欧拉公式 对于平面图，设 $V$ 为点数，$E$ 为边数, $F$ 为区域数量（不闭合的区域也算一个区域），$C$ 为连通块数量，有 $$F + V - E = C + 1$$ 这里我们要求的就是 $C$。 $V$ 可以直接用 $(x_2 - x_1 + 1) \\times (y_2 - y_1 +1)$ 算出； $E$ 可以预处理二维前缀和，然后每次询问的时候再遍历边界，把边界的边删除； $F$ 稍微要想点方法，我们先对整张图 BFS 一遍，然后对于每个区域，选择一个关键点来表示它。然后我们预处理出关键点数量的二维前缀和。在询问时，边界上所有没有闭合的区域都只能算作一个区域，所以我们要减去边界上没有闭合的且关键点在询问矩阵内的区域，并开个桶记录哪些区域已经被删除了，就不会重复统计了。 复杂度为 $O(NM + Q(M+N))$。 ","date":"2021-03-02","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ausaco21jan-paint-by-letters-p/:2:0","tags":["OI","解题报告","平面图","欧拉公式","USACO"],"title":"[解题报告][USACO21JAN] Paint by Letters P","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ausaco21jan-paint-by-letters-p/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e #define mkp make_pair #define fi first #define se second using namespace std; const int _ = 1e3 + 7; const int __ = 1e6 + 7; int N, M, Q, area[_][_], sumE[_][_], sumF[_][_], cnt; char A[_][_]; pair\u003cint, int\u003e rep[__]; bool vis[_][_], del[__]; queue\u003cpair\u003cint, int\u003e\u003e q; void Extend(int x, int y) { if (!vis[x][y]) q.push(mkp(x, y)), vis[x][y] = 1, area[x][y] = cnt; } void Bfs(int sx, int sy) { q.push(mkp(sx, sy)), vis[sx][sy] = 1, area[sx][sy] = ++cnt; rep[cnt] = mkp(sx, sy), ++sumF[sx][sy]; while (!q.empty()) { int x = q.front().fi, y = q.front().se; q.pop(); if (x + 1 \u003c N and A[x + 1][y] != A[x + 1][y + 1]) Extend(x + 1, y); if (y + 1 \u003c M and A[x][y + 1] != A[x + 1][y + 1]) Extend(x, y + 1); if (x \u003e 1 and A[x][y] != A[x][y + 1]) Extend(x - 1, y); if (y \u003e 1 and A[x][y] != A[x + 1][y]) Extend(x, y - 1); } } bool Check(pair\u003cint, int\u003e pt, int x1, int x2, int y1, int y2) { return pt.fi \u003e= x1 and pt.fi \u003c= x2 and pt.se \u003e= y1 and pt.se \u003c= y2; } int main() { cin \u003e\u003e N \u003e\u003e M \u003e\u003e Q; for (int i = 1; i \u003c= N; ++i) scanf(\"%s\", A[i] + 1); for (int i = 1; i \u003c= N; ++i) for (int j = 1; j \u003c= M; ++j) if (!vis[i][j]) Bfs(i, j); for (int i = 1; i \u003c= N; ++i) for (int j = 1; j \u003c= M; ++j) { sumE[i][j] = sumE[i - 1][j] + sumE[i][j - 1] - sumE[i - 1][j - 1] + (A[i][j] == A[i - 1][j]) + (A[i][j] == A[i][j - 1]); sumF[i][j] = sumF[i][j] + sumF[i - 1][j] + sumF[i][j - 1] - sumF[i - 1][j - 1]; } for (int t = 1, x1, y1, x2, y2; t \u003c= Q; ++t) { scanf(\"%d%d%d%d\", \u0026x1, \u0026y1, \u0026x2, \u0026y2); int V = (x2 - x1 + 1) * (y2 - y1 + 1); int E = sumE[x2][y2] - sumE[x1 - 1][y2] - sumE[x2][y1 - 1] + sumE[x1 - 1][y1 - 1]; for (int i = x1; i \u003c= x2; ++i) if (A[i][y1] == A[i][y1 - 1]) --E; for (int j = y1; j \u003c= y2; ++j) if (A[x1][j] == A[x1 - 1][j]) --E; int F = sumF[x2 - 1][y2 - 1] - sumF[x1 - 1][y2 - 1] - sumF[x2 - 1][y1 - 1] + sumF[x1 - 1][y1 - 1] + 1; for (int i = x1; i \u003c x2; ++i) { if (A[i][y1] != A[i + 1][y1] and Check(rep[area[i][y1]], x1, x2 - 1, y1, y2 - 1) and !del[area[i][y1]]) del[area[i][y1]] = 1, --F; if (A[i][y2] != A[i + 1][y2] and Check(rep[area[i][y2 - 1]], x1, x2 - 1, y1, y2 - 1) and !del[area[i][y2 - 1]]) del[area[i][y2 - 1]] = 1, --F; } for (int j = y1; j \u003c y2; ++j) { if (A[x1][j] != A[x1][j + 1] and Check(rep[area[x1][j]], x1, x2 - 1, y1, y2 - 1) and !del[area[x1][j]]) del[area[x1][j]] = 1, --F; if (A[x2][j] != A[x2][j + 1] and Check(rep[area[x2 - 1][j]], x1, x2 - 1, y1, y2 - 1) and !del[area[x2 - 1][j]]) del[area[x2 - 1][j]] = 1, --F; } for (int i = x1; i \u003c x2; ++i) del[area[i][y1]] = del[area[i][y2 - 1]] = 0; for (int j = y1; j \u003c y2; ++j) del[area[x1][j]] = del[area[x2 - 1][j]] = 0; printf(\"%d\\n\", F + V - E - 1); } return 0; } ","date":"2021-03-02","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ausaco21jan-paint-by-letters-p/:3:0","tags":["OI","解题报告","平面图","欧拉公式","USACO"],"title":"[解题报告][USACO21JAN] Paint by Letters P","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ausaco21jan-paint-by-letters-p/"},{"categories":null,"content":"2/17 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:1:0","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"[bzoj3728]Zarowki (模拟费用流) 题面 时间：16:10 ~ 17:00 标签：模拟费用流 难度：中下 代码 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:1:1","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"2/26 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:2:0","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"[AHOI2009]最小割（网络流、Tarjan） 题面 时间：16:30 ~ 17:30 标签：网络流、Tarjan 难度：中下（模板） 解题报告 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:2:1","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"2/27 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:3:0","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"luoguP4311 士兵占领（网络流） 题面 时间：9:30 ~ 10:10 标签：网络流，逆向思维 难度：中下 解题报告 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:3:1","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"[WC2007]剪刀石头布（费用流） 题面 时间：11:00 ~ 11:50 + 14:00 ~ 14:45 标签：费用流 难度：中 解题报告 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:3:2","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"[清华集训2017]无限之环（费用流） 题面 时间：15:10 ~ 17;30 + 19:00 ~ 20:30 标签：费用流、神仙建图 难度：中上 备注：这题总的思路不复杂，但是不看题解完全写不出来。 解题报告 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:3:3","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"CF708D Incorrect Flow（上下界最大流） 题面 时间：21:30 ~ 22:30s 标签：上下界最大流 难度：中 备注：大概就是个上下界有源汇最大流板子，但做的时候脑子抽了没想出来怎么建图。 代码 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:3:4","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"3/2 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:4:0","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"「LibreOJ NOI Round #2」签到游戏（GCD、线段树） 题面 时间：(3/1)22:30 ~ 22:50 + (3/2)14:00 ~ 15:15 标签：GCD、线段树 难度：中 备注： 利用「固定左端点（右端点），区间不同 GCD 个数为 $O(\\log)$」这条性质，用线段树维护区间 GCD，然后每次暴力建出固定左端点（右端点）的 $O(\\log)$ 个 GCD 不同的区间，然后二分，check 的时候暴力算前缀和即可。 二分 check 的时候要注意一下边界，考虑的时候要仔细讨论。 代码 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:4:1","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":null,"content":"[USACO21JAN] Paint by Letters P 题面 时间：18:40 ~ 19:50 标签：平面图欧拉公式 难度：中下 备注：基本上是欧拉公式板子题，没见过的话就真的做不出来。 解题报告 ","date":"2021-02-27","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:4:2","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 一个 $n \\times m$ 的网格，每个网格中可能有一个以下15类水管中的一个。 可以花费代价 1 ，逆时针或顺时针90°旋转一个格子里的水管。 求最小代价使得所有水管形成若干个环。 $ n \\times m \\le 2000$。 Solution 网络流建图系列之——那些不看题解就完全想不出来的建图。 首先由于水管是在网格上面，所以先考虑利用二分图的性质。 在每个格子中央建一个水管； 对于所有白色格子 $i$， 从 $S$ 向 $i$ 连一条容量为接口数量，费用为 0 的边； 对于所有给色格子 $j$， 从 $j$ 向 $T$ 连一条容量为接口数量，费用为 $0$ 的边。 然后对每个格子 $i$ 的 4 个边界分别建一个节点，设为 $k \\times n \\times m + i$，然后对一条边线两侧的节点连一条容量为 1，费用为 0 的边，方向从白色一侧连向黑色一侧。 然后我们现在考虑对于所有白点，如何从 $i$ 向 $k \\times n \\times m + i$ 连边。（对于黑点来说就是把所有边反向。） 大致的思路就是：用旋转后的方向占用旋转前的方向的容量。 设 $(c,w)$ 表示容量为 $c$，费用为 $w$ 的边。分类讨论一下： 对于只有一个接口的水管： 从中央节点向该接口方向连边 $(1, 0)$； 从中央节点向与该接口相邻的两个方向连边 $(1, 1)$； 从中央节点向与该接口相对的方向连边 $(1, 2)$。 对于 L 字形的水管： 从中央节点向两个接口的方向连边 $(1, 0)$; 分别从两个接口对应的节点向它相对方向连边 $(1, 1)$。 对于 T 字形水管： 从中央节点向三个接口的方向连边 $(1, 0)$; 从 $T$ 字顶部横线的那两个方向的节点向没有接口的方向连边 $(1, 1)$； 从 $T$ 字形底部的节点向没有接口的方向连边 $(1, 2)$。 对于剩余的水管，要么是不能旋转，要么是旋转后没有变化，所以只需要从中央节点向有接口的方向连边即可。 对于黑色格子，把所有连边反向即可。 最后在这张图上跑最小费用最大流。 若所有白格子的接口数量总和等于黑格子的接口数量总和，且最大流等于白格子接口数量和，则答案为最小费用； 否则无解，输出 -1 即可。 ","date":"2021-02-27","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%E6%97%A0%E9%99%90%E4%B9%8B%E7%8E%AF/:0:0","tags":["OI","解题报告","网络流","费用流","神仙建图","清华集训","清华集训2017"],"title":"[解题报告][清华集训2017]无限之环","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%E6%97%A0%E9%99%90%E4%B9%8B%E7%8E%AF/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e #define mkp make_pair #define fi first #define se second using namespace std; const int _ = 2e4 + 7; const int __ = 1e5 + 7; const int inf = 1; const int S = 2e4 + 1, T = 2e4 + 2; int n, m, nm, All[2], MaxFlow, Cst; int dis[_], dep[_], lst[_], cur[_], nxt[__], to[__], cap[__], wgt[__], tot = 1; bool b[_]; queue\u003cint\u003e q; int Num(int i, int j) { if (i \u003c 1 or i \u003e n or j \u003c 1 or j \u003e m) return 0; return m * (i - 1) + j; } int pop_count(int x) { return (x \u0026 1) + (x \u003e\u003e 1 \u0026 1) + (x \u003e\u003e 2 \u0026 1) + (x \u003e\u003e 3 \u0026 1); } void Add(int x, int y, int c, int w, bool ty = 1) { if (!x or !y) return; if (!ty) swap(x, y); nxt[++tot] = lst[x], to[tot] = y, cap[tot] = c, wgt[tot] = w, lst[x] = tot; nxt[++tot] = lst[y], to[tot] = x, cap[tot] = 0, wgt[tot] = -w, lst[y] = tot; } bool SPFA() { memset(dis, 0x3f, sizeof dis), memset(dep, 0, sizeof dep); dis[S] = 0, dep[S] = 1, q.push(S); while (!q.empty()) { int u = q.front(); q.pop(), b[u] = 0; for (int i = lst[u]; i; i = nxt[i]) { int v = to[i]; if (dis[v] \u003c= dis[u] + wgt[i] or !cap[i]) continue; dis[v] = dis[u] + wgt[i], dep[v] = dep[u] + 1; if (!b[v]) q.push(v), b[v] = 1; } } return dis[T] != dis[0]; } int Extend(int u, int flow) { if (u == T) return flow; int res = flow; for (int \u0026i = cur[u]; i; i = nxt[i]) { int v = to[i]; if (dis[v] != dis[u] + wgt[i] or dep[v] != dep[u] + 1 or !cap[i]) continue; int cst = Extend(v, min(res, cap[i])); cap[i] -= cst, cap[i ^ 1] += cst, res -= cst; if (!res) break; } return flow - res; } void Dinic() { int flow; while (SPFA()) { memcpy(cur, lst, sizeof lst); do { flow = Extend(S, inf); MaxFlow += flow; Cst += flow * dis[T]; } while (flow); } } int main() { cin \u003e\u003e n \u003e\u003e m; nm = n * m; for (int i = 1, x, id, cnt, ty; i \u003c= n; ++i) for (int j = 1; j \u003c= m; ++j) { scanf(\"%d\", \u0026x), cnt = pop_count(x), id = Num(i, j), ty = (i + j) \u0026 1; if (!cnt) continue; All[ty] += cnt; if (ty) Add(S, id, cnt, 0); else Add(id, T, cnt, 0); for (int k = 0; k \u003c 4; ++k) if (x \u003e\u003e k \u0026 1) Add(id, (k + 1) * nm + id, 1, 0, ty); bool flag = cnt == 2 and (((x \u003e\u003e 0 \u0026 1) and (x \u003e\u003e 2 \u0026 1)) or ((x \u003e\u003e 1 \u0026 1) and (x \u003e\u003e 3 \u0026 1))); if (cnt == 1) { int t = 0; for (int k = 0; k \u003c 4; ++k) if (x \u003e\u003e k \u0026 1) t = k; for (int k = 0; k \u003c 4; ++k) if ((k - t + 4) % 4 == 2) Add(id, (k + 1) * nm + id, 1, 2, ty); else if (k != t) Add(id, (k + 1) * nm + id, 1, 1, ty); } if (cnt == 2 and !flag) { for (int k = 0; k \u003c 4; ++k) if (x \u003e\u003e k \u0026 1) Add((k + 1) * nm + id, ((k + 2) % 4 + 1) * nm + id, 1, 1, ty); } else if (cnt == 3) { int t = 0; for (int k = 0; k \u003c 4; ++k) if (!(x \u003e\u003e k \u0026 1)) t = k; Add(((t + 2) % 4 + 1) * nm + id, (t + 1) * nm + id, 1, 2, ty); Add(((t + 1) % 4 + 1) * nm + id, (t + 1) * nm + id, 1, 1, ty); Add(((t + 3) % 4 + 1) * nm + id, (t + 1) * nm + id, 1, 1, ty); } if (ty) { int n1 = Num(i - 1, j), n2 = Num(i, j + 1), n3 = Num(i + 1, j), n4 = Num(i, j - 1); if (n1) Add(1 * nm + id, 3 * nm + n1, 1, 0); if (n2) Add(2 * nm + id, 4 * nm + n2, 1, 0); if (n3) Add(3 * nm + id, 1 * nm + n3, 1, 0); if (n4) Add(4 * nm + id, 2 * nm + n4, 1, 0); } } if (All[0] != All[1]) { puts(\"-1\"); exit(0); } Dinic(); printf(\"%d\\n\", MaxFlow == All[0] ? Cst : -1); return 0; } ","date":"2021-02-27","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%E6%97%A0%E9%99%90%E4%B9%8B%E7%8E%AF/:1:0","tags":["OI","解题报告","网络流","费用流","神仙建图","清华集训","清华集训2017"],"title":"[解题报告][清华集训2017]无限之环","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%E6%97%A0%E9%99%90%E4%B9%8B%E7%8E%AF/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 给定一个 $n$ 个点的竞赛图，有一些边已经确定方向，要求你为剩下的边定向，并使得图中三元环数量尽量多。 输出最多的三元环数量以及一种定向方案。 $n \\le 100$。 Solution 一个三元组 $(i, j, k)$ （$i,j,k$ 互不相同）不构成三元环当且仅当存在一个点的入度或出度等于2。 那么三元环个数可以表示为 $$ \\mathrm{num} = \\binom{n}{3} - \\sum_{i = 1}^n \\binom{indeg_i}{2} $$ 要是三元环数量尽量多，我们感性上就是要使每个点的入度尽量的少。 而为边 $(u,v)$ 定向的过程就相当于把 $u$ 的入度加一或把 $v$ 的入度加一。 而假设一个点 $i$ 当前的入度为 $indeg_i$，那么它的入度加一后，它贡献的代价的变化量为 $\\binom{indeg_i + 1}{2} - \\binom{indeg_i}{2}$。 所以我们可以这样连边： 对于每一条未定向的边 $j$，从 $S$ 向 $n + j$ 连一条容量为 $1$，费用为 $0$ 的边； 对每一条未定向的边 $j = (u, v)$，从 $n + j$ 分别向 $u,v$ 连一条容量为 $1$，费用为 $0$ 的边； 对每个点 $i$，设它初始时的入度为 $indeg_i$，从 $i$ 向 $T$ 分别连 $n - 1 - indeg_i$ 条容量为 $1$， 费用为 $\\binom{k}{2} - \\binom{k - 1}{2} (k \\in [indeg_i + 1, n - 1])$ 的边。 在这张图上跑最小费用最大流。设最小费用为 $\\mathrm{cost}$，则最终答案为 $$ \\mathrm{num} = \\binom{n}{3} - \\sum_{i = 1}^n \\binom{indeg_i}{2} - \\mathrm{cost} $$ $n \\le 3$ 的情况可能需要特判一下。 构造方案只需要对于每一条未定向的边 $(u,v)$ 看它连向 $u$ 的边满流还是连向 $v$ 的边满流即可。 复杂度为 $O(费用流(n^2, n^2))$。 Code #include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e #define mkp make_pair #define fi first #define se second using namespace std; const int _ = 2e4 + 7; const int __ = 1e5 + 7; const int inf = 1e9; const int S = 2e4 + 1, T = 2e4 + 2; int n, ind[_], a[107][107], cnt, ans; int dis[_], dep[_], lst[_], cur[_], nxt[__], to[__], cap[__], wgt[__], tot = 1; bool b[_]; queue\u003cint\u003e q; pair\u003cint, int\u003e e[_]; void Add(int x, int y, int c, int w) { nxt[++tot] = lst[x], to[tot] = y, cap[tot] = c, wgt[tot] = w, lst[x] = tot; nxt[++tot] = lst[y], to[tot] = x, cap[tot] = 0, wgt[tot] = -w, lst[y] = tot; } int C2(int n) { return n ? 1ll * n * (n - 1) / 2 : 0; } bool SPFA() { memset(dis, 0x3f, sizeof dis); memset(dep, 0, sizeof dep); dis[S] = 0, dep[S] = 1, q.push(S); while (!q.empty()) { int u = q.front(); q.pop(); b[u] = 0; for (int i = lst[u]; i; i = nxt[i]) { int v = to[i]; if (dis[v] \u003c= dis[u] + wgt[i] or !cap[i]) continue; dis[v] = dis[u] + wgt[i], dep[v] = dep[u] + 1; if (!b[v]) q.push(v), b[v] = 1; } } return dis[T] != dis[0]; } int Extend(int u, int flow) { if (u == T) return flow; int res = flow; for (int \u0026i = cur[u]; i; i = nxt[i]) { int v = to[i]; if (dis[v] != dis[u] + wgt[i] or dep[v] != dep[u] + 1 or !cap[i]) continue; int cst = Extend(v, min(cap[i], res)); cap[i] -= cst, cap[i ^ 1] += cst, res -= cst; if (!res) break; } return flow - res; } void Dinic() { int flow; while (SPFA()) { memcpy(cur, lst, sizeof lst); do { flow = Extend(S, inf); ans -= dis[T] * flow; } while (flow); } } int main() { cin \u003e\u003e n; ans = 1ll * n * (n - 1) * (n - 2) / 6; for (int i = 1; i \u003c= n; ++i) for (int j = 1; j \u003c= n; ++j) scanf(\"%d\", \u0026a[i][j]); for (int i = 1; i \u003c= n; ++i) for (int j = i + 1; j \u003c= n; ++j) if (a[i][j] == 0) ++ind[i]; else if (a[i][j] == 1) ++ind[j]; else { e[++cnt] = mkp(i, j); Add(S, cnt + n, 1, 0); Add(cnt + n, i, 1, 0); Add(cnt + n, j, 1, 0); } for (int i = 1; i \u003c= n; ++i) { ans -= C2(ind[i]); for (int j = ind[i] + 1; j \u003c n; ++j) Add(i, T, 1, C2(j) - C2(j - 1)); } Dinic(); cout \u003c\u003c (n \u003c 3 ? 0 : ans) \u003c\u003c endl; for (int u = 1; u \u003c= cnt; ++u) for (int i = lst[n + u]; i; i = nxt[i]) { int v = to[i]; if (v == e[u].fi and !cap[i]) { a[e[u].fi][e[u].se] = 0; break; } if (v == e[u].se and !cap[i]) { a[e[u].fi][e[u].se] = 1; break; } } for (int i = 1; i \u003c= n; ++i) for (int j = 1; j \u003c i; ++j) a[i][j] = 1 - a[j][i]; for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= n; ++j) printf(\"%d \", a[i][j]); putchar('\\n'); } return 0; } ","date":"2021-02-27","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Awc2007%E5%89%AA%E5%88%80%E7%9F%B3%E5%A4%B4%E5%B8%83/:0:0","tags":["OI","解题报告","网络流","费用流","WC","WC2007"],"title":"[解题报告][WC2007]剪刀石头布","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Awc2007%E5%89%AA%E5%88%80%E7%9F%B3%E5%A4%B4%E5%B8%83/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 一个 $n \\times m$ 的网格，有 $K$ 个障碍格子，其余格子均可以放一个士兵。 求使得第 $i$ 行士兵数量大于等于 $L_i$，第 $j$ 列士兵数量大于等于 $C_i$ 时的最小士兵放置数量。 $n, m \\le 100, K \\le n \\times m$。 Solution 这题有一个比较显然的上下界网络流解法： 对每一行 $i$，从源点 $S$ 向点 $i$ 连一条下界为 $L_i$ 的边； 对每一列 $j$，从 $n + j$ 向汇点 $T$ 连一条下界为 $C_i$ 的边； 对每一行 $i$ 以及每一列 $j$， 如果格子 $(i,j)$ 不是障碍格子，则从 $i$ 向 $j$ 连一条上界为 $1$ 的边，表示在格子 $(i,j)$ 上放置一个士兵。 建完图后跑一个有源汇的上下界网络流即可。 但是我们会发现，这张图从 $S$ 连向 $1 \\sim n$ 以及从 $n + 1 \\sim n + m$ 连向 $T$ 的这些边都只有下界没有上界，那么我们是否可以对模型做一些改变，把下界改为上界，就可以使用普通最大流算法来解决这个问题了。 我们从逆向考虑这个问题。先假设一开始在所有的非障碍格子都放了一个士兵，然后接下来我们要计算的就是：在满足限制的情况下，最多能够删掉多少个士兵。 我们设 $totL_i$ 表示第 $i$ 行的非障碍格子数量，$totC_j$ 表示第 $j$ 列的非障碍格子数量。 对于每一行 $i$，从源点 $S$ 向点 $i$ 连一条容量为 $totL_i - L_i$ 的边； 对于每一行 $j$，从 $n + j$ 向汇点 $T$ 连一条容量为 $totC_i - C_i$ 的边； 对于每一行 $i$ 和每一行 $j$，从 $i$ 向 $n + j$ 连一条容量为 $1$ 的边。 在这张图上跑最大流算法，最终的答案就是 $n \\times m - K - \\mathrm{max\\_flow}$。 Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e using namespace std; const int _ = 2e2 + 7; const int __ = 2e4 + 7; const int inf = 1e9; const int S = 2e2 + 1, T = 2e2 + 2; int n, m, K, L[_], C[_], totL[_], totC[_], maxflow; bool b[_][_]; int dis[_], lst[_], cur[_], nxt[__], to[__], cap[__], tot = 1; queue\u003cint\u003e q; void Add(int x, int y, int c) { nxt[++tot] = lst[x], to[tot] = y, cap[tot] = c, lst[x] = tot; nxt[++tot] = lst[y], to[tot] = x, cap[tot] = 0, lst[y] = tot; } bool Bfs() { memset(dis, 0, sizeof dis); while (!q.empty()) q.pop(); dis[S] = 1, q.push(S); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = lst[u]; i; i = nxt[i]) { int v = to[i]; if (dis[v] or !cap[i]) continue; dis[v] = dis[u] + 1, q.push(v); if (v == T) return 1; } } return 0; } int Extend(int u, int flow) { if (u == T) return flow; int res = flow; for (int \u0026i = cur[u]; i; i = nxt[i]) { int v = to[i]; if (dis[v] != dis[u] + 1 or !cap[i]) continue; int cst = Extend(v, min(cap[i], res)); cap[i] -= cst, cap[i ^ 1] += cst, res -= cst; if (!res) break; } return flow - res; } void Dinic() { int flow; while (Bfs()) { memcpy(cur, lst, sizeof cur); do { flow = Extend(S, inf); maxflow += flow; } while (flow); } } int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e K; for (int i = 1; i \u003c= n; ++i) cin \u003e\u003e L[i], totL[i] = m; for (int i = 1; i \u003c= m; ++i) cin \u003e\u003e C[i], totC[i] = n; for (int i = 1, x, y; i \u003c= K; ++i) { cin \u003e\u003e x \u003e\u003e y; if (!b[x][y]) b[x][y] = 1, --totL[x], --totC[y]; } for (int i = 1; i \u003c= n; ++i) { if (totL[i] \u003c L[i]) { puts(\"JIONG!\"); exit(0); } Add(S, i, totL[i] - L[i]); } for (int i = 1; i \u003c= m; ++i) { if (totC[i] \u003c C[i]) { puts(\"JIONG!\"); exit(0); } Add(n + i, T, totC[i] - C[i]); } for (int i = 1; i \u003c= n; ++i) for (int j = 1; j \u003c= m; ++j) if (!b[i][j]) Add(i, n + j, 1); Dinic(); cout \u003c\u003c n * m - K - maxflow \u003c\u003c endl; return 0; } Reference 题解 P4311 【士兵占领】 by GGN_2015。 ","date":"2021-02-27","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogup4311%E5%A3%AB%E5%85%B5%E5%8D%A0%E9%A2%86/:0:0","tags":["OI","解题报告","网络流","最大流","上下界最大流","洛谷"],"title":"[解题报告][luoguP4311]士兵占领","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogup4311%E5%A3%AB%E5%85%B5%E5%8D%A0%E9%A2%86/"},{"categories":null,"content":"最小割 ","date":"2021-02-27","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"[学习笔记]网络流总结","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"求最小割方案 ","date":"2021-02-27","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%BB%E7%BB%93/:1:0","tags":null,"title":"[学习笔记]网络流总结","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"最小割可行边 ","date":"2021-02-27","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%BB%E7%BB%93/:2:0","tags":null,"title":"[学习笔记]网络流总结","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"最小割必须边 ","date":"2021-02-27","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%BB%E7%BB%93/:3:0","tags":null,"title":"[学习笔记]网络流总结","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%BB%E7%BB%93/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 给定一张 $n$ 个点，$m$ 条边的有向图，并给定源点 $S$ 和汇点 $T$，对每条边进行判断 该边是否可能在最小割中 该边是否一定在最小割中 $n \\le 4 \\times 10^3, m \\le 6 \\times 10^4$. Solution 首先可以感性理解：原图中的重边可以看做一条边，流量为它们流量的总和。 但在代码编写中并不需要将这些边合并，这里提到这一点只是为了便于描述以及对便于以下证明的理解。 一条有向边 $(u,v)$ 可能在最小割中的充要条件： 该边满流。 残量网络上不存在一条从 $u$ 到 $v$ 的路径。即残量网络中 $u$ 和 $v$ 不在同一个 $SCC$ 中。 简证： 首先可以感性理解，不满流的边显然不在最小割中。（因为感觉这部分比较好理解，所以就没有仔细想理性的证明方法，对想知道证明的读者表示歉意。） 然后「边 $(u,v)$ 可能在最小割中」实际上等价于：把 $(u,v)$ 的原流量 $c$ 减小一个极小值 $\\varepsilon$，则新图的最小割 / 最大流会减小。 那么假设 $(u,v)$ 的原流量减小了 $\\varepsilon$，如果新图的最大流也减小了 $\\varepsilon$，则必定存在一条从 $S$ 到 $u$ 的路径以及一条从 $v$ 到 $T$ 的路径，否则就说明原来这条流量为 $\\varepsilon$ 的路径从另外一个地方增广出去了，那么新图的最大流就没有变化，与假设矛盾。 那么现在存在一条从 $S$ 到 $u$ 的路径、一条从 $v$ 到 $T$ 的路径以及一条从 $u$ 到 $v$ 的路径，那么就存在一条从 $S$ 到 $T$ 的增广路，那么新图的最大图就没有变化，与假设矛盾。 于是得证。 一条有向边 $(u,v)$ 一定在最小割中的充要条件： 该边满流。 残量网络中存在一条从 $S$ 到 $u$ 的路径，且存在一条从 $v$ 到 $T$ 的路径。即 $S$ 和 $u$ 在同一个 $SCC$ 中，且 $v$ 和 $T$ 在同一个 $SCC$ 中。 关于「条件 2」： 这里我们不考虑原流量 $c \\le 0$ 的情况。 那么若 $(u,v)$ 满流，则不然存在一条从 $u$ 到 $S$ 的反向路径和一条从 $T$ 到 $v$ 的反向路径。 所以就解释了「条件 2」的中第一句话可以导出第二句话的原因。 简证： 首先满流依然是可以感性理解的，这里不在赘述。 然后「边 $(u,v)$ 一定在最小割中」等价于：把 $(u,v)$ 的原流量 $c$ 增加一个正数 $\\Delta c$，则新图的最小割 / 最大流会增加。 给 $(u,v)$ 的原流量增加一个正数 $\\Delta c$，相当于在残量网络上增加一条边 $(u,v,\\Delta c)$。 那么如果存在一条从 $S$ 到 $u$ 的路径以及一条从 $v$ 到 $T$ 的路径，那么就存在一条从 $S$ 到 $T$ 的增广路，于是新图的最大流会增加，于是就说明边 $(u,v)$ 一定在最小割中。 得证。 于是我们只需要对原图跑一边最大流，然后在残量网络上跑一遍 $Tarjan$ 算法来求出 $SCC$，最后对每条边按照上述的条件判断即可。 复杂度为 $O(Dinic(n, m) + n + m)$。 Code 注：代码中的注释部分记录的是作者在编写代码时出错过的地方，读者可不必在意。 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cmap\u003e#include \u003cqueue\u003e #define mkp make_pair #define fi first #define se second using namespace std; const int _ = 4e3 + 7; const int __ = 12e4 + 7; const int inf = 1e9; int n, m, S, T; int dis[_], lst[_], cur[_], nxt[__], to[__], cap[__], tot = 1; int dfn[_], low[_], stk[_], top, scc[_], Dfn, Scc; bool b[_]; pair\u003cint, int\u003e e[__]; queue\u003cint\u003e q; map\u003cpair\u003cint, int\u003e, bool\u003e con; void Add(int x, int y, int c) { nxt[++tot] = lst[x], to[tot] = y, cap[tot] = c, lst[x] = tot; nxt[++tot] = lst[y], to[tot] = x, cap[tot] = 0, lst[y] = tot; // cap[tot] = c, } bool Bfs() { memset(dis, 0, sizeof dis); while (!q.empty()) q.pop(); dis[S] = 1, q.push(S); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = lst[u]; i; i = nxt[i]) { int v = to[i]; if (dis[v] or !cap[i]) continue; dis[v] = dis[u] + 1, q.push(v); if (v == T) return 1; } } return 0; } int Extend(int u, int flow) { if (u == T) return flow; int res = flow; for (int \u0026i = cur[u]; i; i = nxt[i]) { int v = to[i]; if (dis[v] != dis[u] + 1 or !cap[i]) continue; int cst = Extend(v, min(cap[i], res)); cap[i] -= cst, cap[i ^ 1] += cst, res -= cst; if (!res) break; } return flow - res; } void Dinic() { int maxflow = 0, flow = 0; while (Bfs()) { memcpy(cur, lst, sizeof lst); do { flow = Extend(S, inf); maxflow += flow; } while (flow); } cerr \u003c\u003c \"maxflow: \" \u003c\u003c maxflow \u003c\u003c endl; } void Tarjan(int u, int fa) { dfn[u] = low[u] = ++Dfn, stk[++top] = u, b[u] = 1; for (int i = lst[u]; i; i = nxt[i]) { int v = to[i]; if (!cap[i]) continue; if (!dfn[v]) Tarjan(v, u), low[u] = min(low[u], low[v]); else if (b[v]) low[u] = min(low[u], low[v]); } if (low[u] == dfn[u]) { scc[u] = ++Scc, b[u] = 0; while (stk[top] != u) scc[stk[top]] = Scc, b[stk[top]] = 0, --top; --top; } } int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e S \u003e\u003e T; for (int i = 1, c; i \u003c= m; ++i) { scanf(\"%d%d%d\", \u0026e[i].fi, \u0026e[i].se, \u0026c); Add(e[i].fi, e[i].se, c); } Dinic(); for (int i = 1; i \u003c= n; ++i) if (!dfn[i]) Tarjan(i, 0); for (int u = 1; u \u003c= n; ++u) for (int i = lst[u]; i; i = nxt[i]) if (cap[i]) con[mkp(u, to[i])] = 1; for (int i = 1; i \u003c= m; ++i) printf(\"%d %d\\n\", !con[e[i]] and scc[e[i].fi] != scc[e[i].se], !con[e[i]] and scc[e[i].fi] == scc[S] and scc[e[i].se] == scc[T]); // con[e[i]] return 0; } Reference 题解 P4126 【[AHOI2009]最小割】 by 斗神·君莫笑 PPT 【网络流简单入⻔】 by xzz ","date":"2021-02-27","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aahoi2009%E6%9C%80%E5%B0%8F%E5%89%B2/:0:0","tags":["OI， 解题报告， 网络流， 最小割， 各省省选， AHOI","AHOI2009"],"title":"[解题报告][AHOI2009]最小割","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aahoi2009%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 Solution 考虑从朴素算法开始一步步推导。 我们考虑枚举做对的题目集合 $T$，并计算满足集合 $T$ 中题目总分大于等于 $n$ 的分数分配方案数。即 $$ \\begin{aligned} \\mathrm{Ans} \u0026= \\sum_{T} \\prod_{i \\in T}p_i \\prod_{i \\not \\in T} (1 - p_i) 【T 中题目总分大于等于 n 的合法分配方案数】 \\\\ \u0026= \\sum_{T} p(T) 【T 中题目总分大于等于 n 的合法分配方案数】 \\\\ \\end{aligned} $$ 而题目中对于“合法”的要求是：第 $i$ 道题目分配的分数不能超过 $a_i$。 给题目分配分数可以看做把“小球放进盒子”的模型，而对于这种“盒子对小球的个数有限制”的模型，我们一般会用容斥来计算方案数。 具体来说，就是枚举盒子的每个子集 $A$，钦定 $A$ 中的盒子超出了限制，然后其他盒子就随便放。 因此我们的式子可以化为。 $$ \\begin{aligned} \\mathrm{Ans} \u0026= \\sum_{T} p(T) \\sum_{A} (-1)^{|A|} 【将 N' 个球放进 M 个盒子，且 T 中的盒子的球总数大于等于 n' 的方案数】\\\\ \\end{aligned} $$ 其中 $N' = N - \\sum_{i \\in A} (a_i + 1),\\ n' = n - \\sum_{i \\in A \\cap T} (a_i + 1)$。 现在考虑怎么计算“【】”里描述的那个东西。 这种把球放进盒子里的方案数，我们通常会考虑隔板法。 然后这里为了方便描述，我们设前 $|T|$ 个隔板分别表示集合 $T$ 中的题目。因为球都是一样的，所以这样显然不会影响方案数的计算。 那么为了使得这 $|T|$ 个盒子中球数总和大于等于 $n'$，我们就要让第 $|T|$ 个隔板放在第 $n'$ 个球后面。 所以我们枚举第 $n'$ 个球之前的隔板数量，分别计算隔板放置方案，并求和即可。即 $$ \\sum_{t=0}^{|T|-1} \\binom{n' + t - 1}{t} \\binom{(N' + 1 - n') + (M - 1 - t) - 1}{M - 1 - t} = \\sum_{t=0}^{|T|-1} \\binom{n' + t - 1}{t} \\binom{N' - n' + M - 1 - t}{M - 1 - t} $$ 那么答案的计算式就可以进一步化为 $$ \\begin{aligned} \\mathrm{Ans} \u0026= \\sum_{T} p(T) \\sum_{A} (-1)^{|A|} \\sum_{t=0}^{|T|-1} \\binom{n' + t - 1}{t} \\binom{N' - n' + M - 1 - t}{M - 1 - t} \\\\ \\end{aligned} $$ 现在我们可以开始考虑如何计算了。 首先 $0 \\sim |T| - 1$ 属于可以接受的枚举范围，而前面的枚举 $T$ 和 $A$ 的操作我们可以考虑用 DP 计算系数。 所以大概思路就是对于每一个 $\\sum_{t=0}^{|T|-1}$ 的组合数求和操作，我们计算出它的系数，然后把所有结果累加。 那么我们就要观察这个组合数求和需要知道哪些变量，并根据这些变量来设置 DP 状态。 $\\sum_{t=0}^{|T|-1} \\binom{n' + t - 1}{t} \\binom{N' - n' + M - 1 - t}{M - 1 - t}$ 这个式子中，只有 $M$ 是已知的，所以我们还需要知道 $|T|,N',n'$。 所以我们设 $f_{i,j,k,l}$ 表示考虑到第 $i$ 道题，$|T|=j, N'=k, n'=l$ 的系数总和。转移只需枚举第 $i$ 道题目是否加入 $T$ 集合以及是否加入 $A$ 集合即可。 然后由于 $N'$ 等于 $N$ 减去若干个 $a_i + 1$，$n'$ 等于 $n$ 减去若干个 $a_i + 1$，而题目中有条件：存在 $d$，满足对于所有 $i$ 都有 $d | (a_i+1)$，并且 $N \\le 100 \\times d$。 所以我们可以把 $k,l$ 的意义改为 $N' = N - k \\times d, n' = n - l \\times d$。这样 DP 的复杂度就降为 $O(M^2 (\\frac{N}{d})^2) \\approx 10^8$。 而最后统计答案的复杂度也是 $O(M^2 (\\frac{N}{d})^2)$ 的，所以总复杂度也是 $O(M^2 (\\frac{N}{d})^2)$ 的。 最后统计答案，组合数求和时，可以需要特判一下 $n' \\le 0$ 的情况。 Summary 这道题的解题逻辑还是比较清晰的，唯一不太想得到的可能就只有【将 N' 个球放进 M 个盒子，且 T 中的盒子的球总数大于等于 n' 的方案数】这个东西。 但问题是推式子的时候比较难冷静下来，而且容易去想一些奇奇怪怪的东西，从而绕很多弯路，而这种推导的时候一旦方向偏了就比较难搞了。 Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = 1e2 + 7; const int mod = 998244353; int M, d, N, n, a[_], aa[_], p[_], f[_][_][_], g[_][_][_], inv[_], C1[_], C2[_], ans; int main() { cin \u003e\u003e M \u003e\u003e d \u003e\u003e N \u003e\u003e n; for (int i = 1; i \u003c= M; ++i) { scanf(\"%d%d\", \u0026a[i], \u0026p[i]); aa[i] = (a[i] + 1) / d; } inv[1] = 1; for (int i = 2; i \u003c= M; ++i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; f[0][0][0] = 1; for (int i = 1; i \u003c= M; ++i) { for (int j = 0; j \u003c= i; ++j) for (int k = 0; k \u003c= N / d; ++k) { for (int l = 0; l \u003c= k; ++l) { unsigned long long t1 = 0, t2 = 0, t3 = 0, t4 = 0; if (j) t1 = 1ll * f[j - 1][k][l] * p[i]; if (j and l \u003e= aa[i] and k \u003e= aa[i]) t2 = 1ll * f[j - 1][k - aa[i]][l - aa[i]] * p[i]; if (k \u003e= aa[i]) t3 = 1ll * f[j][k - aa[i]][l] * (1 - p[i] + mod); t4 = 1ll * f[j][k][l] * (1 - p[i] + mod); g[j][k][l] = ((t1 + t4) % mod + mod - (t2 + t3) % mod) % mod; } } memcpy(f, g, sizeof f), memset(g, 0, sizeof g); } for (int j = 1; j \u003c= M; ++j) for (int k = 0; k \u003c= N / d; ++k) for (int l = 0; l \u003c= k; ++l) { if (l * d \u003e N) continue; int NN = N - k * d, nn = max(0, n - l * d); if (nn \u003e NN) continue; C1[0] = 1, C2[j - 1] = 1; for (int t = 1; t \u003c= j - 1; ++t) C1[t] = 1ll * C1[t - 1] * (nn - 1 + t) % mod * inv[t] % mod; for (int t = 1; t \u003c= M - 1 - (j - 1); ++t) C2[j - 1] = 1ll * C2[j - 1] * (NN - nn + t) % mod * inv[t] % mod; for (int t = j - 2; t \u003e= 0; --t) C2[t] = 1ll * C2[t + 1] * (NN - nn + M - 1 - t) % mod * inv[M - 1 - t] % mod; if (nn == 0) { ans = (ans + 1ll * C2[0] * f[j][k][l] % mod) % mod; continue; } int res = 0; for (int t = 0; t \u003c j; ++t) res = (res + 1ll * C1[t] * C2[t]) % mod; ans = (ans + 1ll * res * f[j][k][l] % mod) % mod; } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-02-26","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday3%E5%BC%B5%E5%A3%AB%E8%B6%85%E4%BD%A0%E6%98%A8%E5%A4%A9%E6%99%9A%E4%B8%8A%E5%88%B0%E5%BA%95%E6%8A%8A%E6%88%91%E5%AE%B6%E9%91%B0%E5%8C%99%E6%94%BE%E5%9C%A8%E5%93%AA%E4%BA%86/:0:0","tags":["OI","解题报告","计数","DP","容斥","小球","国集集训"],"title":"[解题报告][2020五校国集集训Day3]張士超你昨天晚上到底把我家鑰匙放在哪了？","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday3%E5%BC%B5%E5%A3%AB%E8%B6%85%E4%BD%A0%E6%98%A8%E5%A4%A9%E6%99%9A%E4%B8%8A%E5%88%B0%E5%BA%95%E6%8A%8A%E6%88%91%E5%AE%B6%E9%91%B0%E5%8C%99%E6%94%BE%E5%9C%A8%E5%93%AA%E4%BA%86/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 Solution ","date":"2021-02-25","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/:0:0","tags":["OI","解题报告","DP","DP套DP","计数","卢卡斯定理","国集集训"],"title":"[解题报告][2020五校国集集训Day2]高维游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"问题转化 由于是求 $\\bmod 2$ 意义下的方案数, 所以我们考虑先用卢卡斯定理来简化问题. 假设我们先枚举出每一维走的步数, 设向量 $w$, 它的第 $i$ 维元素 $w_i$ 表示在第 0 阶段中在第 $i$ 维走的步数. 那么满足向量 $w$ 的游走方案为. $$ \\binom{t_0}{w_1, w_2, \\cdots, w_m} \\prod_{i = 1}^m \\binom{t_i}{w_i} $$ 展开后也就是 $$ \\binom{t_0}{w_1} \\binom{t_0 - w_1}{w_2} \\binom{t_0 - w_1 - w_2 - \\cdots - w_{m - 1}}{w_m} \\prod_{i = 1}^m \\binom{t_i}{w_i} $$ 根据卢卡斯定理 $\\binom{n}{m} \\equiv \\binom{\\lfloor n / 2 \\rfloor}{\\lfloor m / 2 \\rfloor} \\binom{n \\bmod 2}{m \\bmod 2} \\pmod 2$, 如果我们要使上述式子为 1, 则要满足 对于所有 $i \\in [1,m]$, 满足 $w_i$ 按位或 $t_i$ 的结果等于 $t_i$, 这里我们称为 $w_i \\subseteq t_i$. 对于所有 $i \\in [1, m]$, 满足 $w_i \\subseteq t_0 - \\sum_{j = 1}^{i - 1} w_j$, 直观上来说, 就是 $w_{1 \\cdots m}$ 构成了 $t_0$ 的一个**不完全划分** . 那么我们可以通过一个类似数位DP的过程来计算满足这个条件的游走方案数. ","date":"2021-02-25","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/:1:0","tags":["OI","解题报告","DP","DP套DP","计数","卢卡斯定理","国集集训"],"title":"[解题报告][2020五校国集集训Day2]高维游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"DP 首先很容易想到一个 naive 的 DP: 设 $f_{i,v}$ 表示进行到二进制第 $i$ 为, 得到的总代价为 $v$ 的游走方案在模2意义下的结果. 转移的话只需枚举每一位取 $1\\sim m$ 中的哪一维 (或者不选) 即可, 复杂度为 $O(tm\\log t_0)$. ","date":"2021-02-25","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/:2:0","tags":["OI","解题报告","DP","DP套DP","计数","卢卡斯定理","国集集训"],"title":"[解题报告][2020五校国集集训Day2]高维游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"优化 注意到每一步游走的代价最多只有 $m$, 而 $m \\le 10$, 所以对于当前的 $i$, 合法的代价 $v$ 不会大出 $2^i$ 太多. 并且假设我们把 $v$ 按二进制位考虑, $v$ 中小于 $2^{i + 1}$ 的部分已经固定了, 在之后的转移中都不会改变, 所以我们可以认为只有 $v$ 中大于等于 $2^{i + 1}$ 的部分才是对转移有用的. 那么我们可以考虑把 $v$ 表示成 $v' + q2^{i + 1} (v' \\le 2^{i + 1})$ 的形式. 然后因为 $v \\le \\sum_{j = 1}^i m2^j \u003c m2^{i+1}$, 所以 $q \\in [0, m)$. 然后重新设一个DP状态: $f_{i, v', q}' = f_{i,v}$, 转移是类似的. 然后由于后面的转移只与 $q$ 有关, 所以对于一对 $(v_1, v_2)$, 若满足对于所有 $q \\in [0, m)$, 都有 $f_{i, v_1,q} = f_{i, v_2, q}$, 那么它们后面的转移方向都是一样的, 所以我们可以考虑把这两个状态合并起来以简化复杂度. 所以我们新设一个DP: $g_{i, S}$ 表示进行到第 $i$ 位, 对于所有 $q \\in [0, m)$ 满足 $f_{i,v,q} = S_q$ 的 $v$ 的数量. 其中 $S_q$ 表示 $S$ 的二进制表示下的第 $q$ 位数字. 转移的话, 假设当前得出了 $g_{i - 1, S}$, 我们枚举 $a,b$, 表示 $S$ 中的第 $a$ 位以及当前选择第 $b$ 维进行游走. 那么总代价就是 $$ v' + (a + b)2^{i} = v' + r2^i + ((a + b) » 1))2^{i + 1} = v' + r2^i + c2^{i + 1} $$ 我们设两个变量 $T_0, T_1$, 若 $r = 0$, 则在 $T_0$ 的第 $c$ 位异或上 1, 否则就在 $T_1$ 的第 $c$ 位异或上 1. 最后转移到 $g_{i, T_0}$ 和 $g_{i, T_1}$ 即可. 这样复杂度为 $O(2^m m^2 \\log t_0) \\approx 3 \\times 10^6$, 再乘上 $200$ 组测试数据, $\\approx 6 \\times 10^8$, 1s 的时限内显然过不了. 再继续考虑优化转移过程, 我们发现枚举 $a,b$ 后, 得到的 $r$ 只有 $0,1$ 两种可能, 而 $c = (a + b) » 1 = \\lfloor (a + b) / 2 \\rfloor$ 也只有两种可能 : $\\lfloor a / 2 \\rfloor + \\lfloor b / 2 \\rfloor$ 或 $\\lfloor a / 2 \\rfloor + \\lfloor b / 2 \\rfloor + 1$. 只需要把 $a,b$ 分奇偶讨论一下就行了. 所以我们可以设两个变量 $S_0, S_1$, 分别把 $S$ 中每个 $a$ 为偶和 $a$ 为奇的情况记录下来, 然后枚举每个 $b$, 按奇偶讨论转移即可. 复杂度为 $O(2^m m \\log t_0) \\approx 3 \\times 10^5$. 在 $200$ 组数据的情况下可以通过. ","date":"2021-02-25","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/:3:0","tags":["OI","解题报告","DP","DP套DP","计数","卢卡斯定理","国集集训"],"title":"[解题报告][2020五校国集集训Day2]高维游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = 10 + 7; const int __ = (1 \u003c\u003c 10) + 7; const int L = 30; int m, t[_]; long long g[__], h[__]; void Solve() { cin \u003e\u003e m; for (int i = 0; i \u003c= m; ++i) scanf(\"%d\", \u0026t[i]); memset(g, 0, sizeof g), memset(h, 0, sizeof h); g[1] = 1; for (int i = 0; i \u003c= L; ++i) { for (int s = 1; s \u003c (1 \u003c\u003c m); ++s) { int s0 = 0, s1 = 0, t0 = 0, t1 = 0; for (int a = 0; a \u003c m; ++a) (a \u0026 1 ? s1 : s0) |= (s \u003e\u003e a \u0026 1) \u003c\u003c (a / 2); for (int b = 0; b \u003c= m; ++b) { if (b and !((t[b] \u0026 t[0]) \u003e\u003e i \u0026 1ll)) continue; if (b \u0026 1) t0 ^= s1 \u003c\u003c (b / 2 + 1), t1 ^= s0 \u003c\u003c (b / 2); else t0 ^= s0 \u003c\u003c (b / 2), t1 ^= s1 \u003c\u003c (b / 2); } h[t0] += g[s], h[t1] += g[s]; } memcpy(g, h, sizeof h), memset(h, 0, sizeof h); } long long ans = 0; for (int i = 1; i \u003c (1 \u003c\u003c m); ++i) for (int j = 0; j \u003c m; ++j) if (i \u003e\u003e j \u0026 1) ans += g[i]; cout \u003c\u003c ans \u003c\u003c endl; } int main() { int T; cin \u003e\u003e T; while (T--) Solve(); return 0; } ","date":"2021-02-25","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/:4:0","tags":["OI","解题报告","DP","DP套DP","计数","卢卡斯定理","国集集训"],"title":"[解题报告][2020五校国集集训Day2]高维游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 有一个长度为 \\(n\\) 初始元素全为 \\(0\\) 的序列 \\(P\\). 进行 \\(K\\) 操作, 每次选择 \\(a_i\\) 个不同的元素将其 \\(+1\\), 两次不同操作所选择的元素可以相同. 求 \\(K\\) 次操作后 \\(P\\) 中元素乘积的期望乘以总方案数. \\(n \\le 1000, K \\le 20\\). ","date":"2021-02-24","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/:1:0","tags":["OI","解题报告","计数","DP","AtCoder"],"title":"[解题报告][AT5742]Cookie Distribution","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/"},{"categories":["OI","解题报告"],"content":"Solution 乘积算期望比较难搞, 所以首先把它进行转化. 使用 \\(a = \\binom{a}{1}\\) 这个套路, 得到 \\[ \\prod_{i = 1}^n p_i = \\prod_{i = 1}^n \\binom{p_i}{1} \\] 而 \\( \\prod_{i = 1}^n \\binom{p_i}{1} \\) 的组合意义可以解释为: 对于每个 \\(i\\) 在选择到了 \\(i\\) 的若干次操作中选择一个操作的方案数. 然后我们把对象转换一下, 假设先枚举每个 \\(i\\) 所选择的操作 \\(q_i\\), 并设 \\(x_i = \\sum_{j = 1}^n [q_j = i]\\), 那么满足 \\(\\{q\\}\\) 的操作方案数量为 \\[ \\prod_{i = 1}^K \\binom{n - x_i}{a_i - x_i} \\] 那么假设我们枚举序列 \\(\\{x\\}\\), 则答案为 \\[ \\sum_{\\{x\\}} \\binom{n}{x_1, x_2, \\cdots, x_K} \\sum_{i = 1}^K \\binom{n - x_i}{a_i - x_i} \\] 这个可以使用 DP 计算. 具体来说, 就是设 \\(f_{i,j}\\) 表示考虑到第 \\(i\\) 次操作, 共钦定了 \\(j\\) 个节点的 \\(q\\) 的贡献总和. 转移方程为 \\[ f_{i, j} = \\sum_{k = 0}^{\\min(j, a_i)} f_{i - 1, j - k} \\binom{n - k}{a_i - k} \\frac{1}{k!} \\] 最后答案即为 \\(n!\\ \\times f_{K, n}\\). 复杂度为 \\(O(n^2K)\\). ","date":"2021-02-24","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/:2:0","tags":["OI","解题报告","计数","DP","AtCoder"],"title":"[解题报告][AT5742]Cookie Distribution","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 20 + 7; const int __ = 1e3 + 7; const int mod = 1e9 + 7; int n, K, a[_], fac[__], ifac[__], inv[__], f[_][__]; int C(int n, int m) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; } int main() { cin \u003e\u003e n \u003e\u003e K; for (int i = 1; i \u003c= K; ++i) cin \u003e\u003e a[i]; fac[0] = ifac[0] = inv[1] = 1; for (int i = 1; i \u003c= n; ++i) { fac[i] = 1ll * fac[i - 1] * i % mod; if (i != 1) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod; } f[0][0] = 1; for (int i = 1; i \u003c= K; ++i) for (int j = 0; j \u003c= n; ++j) for (int k = 0; k \u003c= min(a[i], j); ++k) f[i][j] = (f[i][j] + 1ll * f[i - 1][j - k] % mod * ifac[k] % mod * C(n - k, a[i] - k) % mod) % mod; cout \u003c\u003c 1ll * f[K][n] * fac[n] % mod \u003c\u003c endl; return 0; } ","date":"2021-02-24","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/:3:0","tags":["OI","解题报告","计数","DP","AtCoder"],"title":"[解题报告][AT5742]Cookie Distribution","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 给定集合 \\( \\{0, 1, 2, \\cdots, 2^n - 1\\} \\), 求满足按位与后二进制中 \\(1\\) 的个数为 \\(4\\) 的倍数的子集 \\(T\\) 的个数. \\(n \\le 10^7\\). 70pts subtask: \\(n \\le 10^5\\). ","date":"2021-02-22","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/:1:0","tags":["计数","推式子","容斥","单位根反演","loj"],"title":"[解题报告][loj6358]前夕","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/"},{"categories":["OI","解题报告"],"content":"Solution 设 \\(f_i\\) 表示 \\(\\{0, 1, \\cdots, 2^i - 1\\}\\) 中满足按位与后 \\(1\\) 的个数为 \\(0\\) 的 非空 子集数量, 则有 \\[ \\mathrm{ans} = 1 + \\sum_{i = 0}^{\\lfloor \\frac{n}{4} \\rfloor} \\binom{n}{4i} f_{n - 4i} \\] (其中 \\(1\\) 表示的是空集.) \\(f_i\\) 的计算可以使用容斥. 我们每次钦定若干个位置, 使得按位与后这些位置为 \\(1\\), 则可以列出式子 \\[ f_i = \\sum_{j = 0}^i (-1)^j \\binom{i}{j} (2^{2^{i - j}} - 1) \\] 把组合数展开后就可以写成卷积的形式, 使用 NTT 就可以做到 \\(O(n \\log n)\\) 的复杂度, 可以通过 \\(n \\le 10^5\\) 的 subtask. 推一下式子, 发现 \\(f\\) 的计算似乎没有什么更好的方法, 那么我们考虑把 \\(f\\) 扔回答案计算式中, 再对整个式子考虑优化. 而上面描述的计算式中, 我们发现 \\(4i\\) 这个东西不太优美, 因为它使得 \\(f\\) 不连续了, 可能会导致推式子的过程中出现一些问题. 所以我们把它改为 \\([4 | i]\\), 并考虑使用单位根反演. 原式为 \\[ \\begin{aligned} \\mathrm{ans} - 1 \u0026= \\sum_{i = 0}^n [4 | i] \\binom{n}{i} f_{n - i} \\\\ \u0026= \\sum_{i = 0}^n [4 | n - i] \\binom{n}{i} f_{i} \\\\ \u0026= \\sum_{i = 0}^n [4 | n - i] \\binom{n}{i} \\sum_{j = 0}^i (-1)^j \\binom{i}{j} (2^{2^{i - j}} - 1) \\\\ \\end{aligned} \\] \\((2^{2^{i - j}} - 1)\\) 这个东西长得过于丑陋, 所以我们考虑把它扔到前面来枚举. \\[ \\begin{aligned} \\mathrm{ans} - 1 \u0026= \\sum_{i = 0}^n [4 | n - i] \\binom{n}{i} \\sum_{j = 0}^i (-1)^{i - j} \\binom{i}{j} (2^{2^j} - 1) \\\\ \u0026= \\sum_{j = 0}^n (2^{2^j} - 1) \\sum_{i = j}^n [4 | n - i] (-1)^{i - j} \\binom{n}{i} \\binom{i}{j} \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\sum_{i = j}^n [4 | n - i] (-1)^{i - j} \\binom{n - j}{i - j} \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\sum_{i = 0}^{n - j} [4 | n - i - j] (-1)^i \\binom{n - j}{i} \\\\ \\end{aligned} \\] 然后把 \\([4 | i + j]\\) 用单位根反演换掉, \\[ \\begin{aligned} \\mathrm{ans} - 1 \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\sum_{i = 0}^{n - j} (-1)^i \\binom{n - j}{i} \\frac{1}{4} \\sum_{k = 0}^3 \\omega_{4}^{k(n - i - j)} \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\frac{1}{4} \\sum_{k = 0}^3 \\omega_{4}^{k(n - j)} \\sum_{i = 0}^{n - j} (-1)^i \\binom{n - j}{i} \\omega_{4}^{-ki} \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\frac{1}{4} \\sum_{k = 0}^3 \\omega_{4}^{k(n - j)} \\sum_{i = 0}^{n - j} \\binom{n - j}{i} (- \\omega_{4}^{-k})^i \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\frac{1}{4} \\sum_{k = 0}^3 \\omega_{4}^{k(n - j)} (1 - \\omega_4^{-k})^{n - j} \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\frac{1}{4} \\sum_{k = 0}^3 (\\omega_{4}^{k} (1 - \\omega_4^{-k}))^{n - j} \\\\ \\end{aligned} \\] 后面那坨东西可以预处理, 前面的组合数和 \\(2\\) 的若干次方可以递推, 所以总复杂度为 \\(O(n)\\), 可以通过全部数据. ","date":"2021-02-22","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/:2:0","tags":["计数","推式子","容斥","单位根反演","loj"],"title":"[解题报告][loj6358]前夕","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 1e7 + 7; const int mod = 998244353; int n, inv[_], pww[4][_], w[4]; int Pw(int a, int p) { int res = 1; while (p) { if (p \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; p \u003e\u003e= 1; } return res; } void pls(int \u0026x, long long y) { x = (x + y) % mod; } int main() { cin \u003e\u003e n; inv[1] = 1; for (int i = 2; i \u003c= n; ++i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; for (int k = 0; k \u003c 4; ++k) w[k] = Pw(Pw(3, (mod - 1) / 4), k); for (int k = 0; k \u003c 4; ++k) { pww[k][0] = 1, pww[k][1] = 1ll * w[k] * (1 - w[(4 - k) % 4] + mod) % mod; for (int i = 2; i \u003c= n; ++i) pww[k][i] = 1ll * pww[k][i - 1] * pww[k][1] % mod; } int C = 1, pw = 2, ans = 0; for (int j = 0; j \u003c= n; ++j) { int res = 0; for (int k = 0; k \u003c 4; ++k) pls(res, pww[k][n - j]); pls(ans, 1ll * C * (pw - 1 + mod) % mod * res % mod); C = 1ll * C * (n - j) % mod * inv[j + 1] % mod; pw = 1ll * pw * pw % mod; } cout \u003c\u003c (1ll * ans * Pw(4, mod - 2) % mod + 1) % mod \u003c\u003c endl; return 0; } ","date":"2021-02-22","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/:3:0","tags":["计数","推式子","容斥","单位根反演","loj"],"title":"[解题报告][loj6358]前夕","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/"},{"categories":["OI","解题报告"],"content":"Postscript 这道题我从 14:30 开始推, 然后在托腮的 \"题解\" 帮助下在 15:30 推完了, 上了个洗手间后把代码写了, 然后没过样例, 然后发现式子推错了, 然后重新推式子, 然后推完了, 然后代码写完了, 然后又没过样例, 然后写了个暴力, 然后发现是组合数递推出错了, 然后就 A 了, 然后已经 17:00 了. 再论wz做题量这么少的原因. ","date":"2021-02-22","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/:4:0","tags":["计数","推式子","容斥","单位根反演","loj"],"title":"[解题报告][loj6358]前夕","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/"},{"categories":["OI","解题报告"],"content":"Statement 题面 一个长度为 \\(n\\) 的序列 \\( \\{ a \\} \\), 有 \\(Q\\) 个形如 \\((l, r, )\\) 的询问, 每次需要回答在区间 \\([l,r]\\) 内选择 恰好 \\(k\\) 个 不相交区间 的元素和最大值. \\( n, Q \\le 35000, |a_i| \\le 35000\\). ","date":"2021-02-19","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/:1:0","tags":["OI","解题报告","数据结构","凸包","凸优化","闵可夫斯基和","CodeForces","300iq"],"title":"[解题报告][300iq Contest 2 H]Honorable Mention","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/"},{"categories":["OI","解题报告"],"content":"Solution 先考虑对于单个询问怎么做. 假设询问区间为 \\([1, n]\\), 设 DP 状态 \\(f_{i, j}\\) 为考虑到第 \\(i\\) 位, 选择了 \\(j\\) 个区间的最大值. 容易得到转移. \\[ f_{i, j} = \\max(f_{i - 1, j}, \\max_{k = 0}^{i - 1} f_{k, j - 1} + sum_{i} - sum_{k}) \\] 其中 \\(\\{ sum \\}\\) 是 \\(\\{ a \\}\\) 的前缀和. 加上一个前缀最大值优化, 我们就得到了一个 \\(O(n^2Q)\\) 的做法. 考虑怎么优化. 如果你见得多或者直觉比较好, 大概可以猜出 \\(F(x) = f_{n, x} (x \\in [1, n])\\) 这个函数可能是凸的. 证明函数凸性的话就考虑是否能建出一个费用流模型, 如果可以, 就表示它一定是凸的. 因为最大费用流的过程中我们总是先拓展费用最大的流, 所以每次拓展的流的费用是递减的, 就相当于函数的变化量 \\( \\Delta \\) 是递减的, 也就表明这函数是个凸函数. 设 \\((u, v, c, w)\\) 为一条从 \\(u\\) 连向 \\(v\\) 的容量为 \\(c\\), 费用为 \\(w\\) 的边. 考虑把每个元素 \\(a_i\\) 拆成一个入点 \\(u_i\\) 和出点 \\(v_i\\), 连接 \\((u_i, v_i, 1, a_i)\\). 然后 \\( \\forall i \\in [1, n - 1] \\), 连接 \\((v_i, u_{i + 1}, 1, 0)\\); \\(\\forall i \\in [1, n]\\), 连接 \\((S, u_i, 1, 0), (v_i, T, 1, 0)\\). 这样就把费用流模型建好了, 所以函数 \\(F(x)\\) 是凸的, 所以我们可以用凸优化来优化它的计算. 假设我们当前要求 \\((l, r, k)\\), 那么我们二分一个斜率 \\(mid\\), 并找出该直线的在凸包上的切点 \\((x, F(x)\\), 若 \\(x \\ge k\\), 则增大 \\(mid\\), 否则减小. 然后找切点就相当于找凸包上距离斜率为 \\(mid\\) 的直线最近的点, 也就是 \\( x \\cdot mid - F(x) \\) 最小的点, 也就是 \\((x, F(x) - x \\cdot mid) \\) 的最高点. 那么我们考虑怎么求 \\(F(x) - x \\cdot mid\\) 的最大值. 设 \\( g_{i} \\) 表示考虑到 \\(i\\) 时的答案, 并且 \\(g_i\\) 是一个 \\(std::pair\\), 第一维记的是 \\(F(x) - x \\cdot mid\\), 第二维记的是 \\(x\\). 那么容易写出转移方程. \\[ g_i = \\max(g_{i - 1}, \\max_{k = 1}^{i - 1} g_k + (sum_i - sum_k, 1)) \\] 同样, 使用前缀和优化的话一次 DP 可以做到 \\(O(n)\\), 所以总复杂度为 \\(O(nQ \\log value)\\). 然而这个 DP 和正解好像并没有什么关系. 想要做到更优的复杂度, 我们可以考虑用一个数据结构来维护凸包. 这里我们使用线段树. 对于线段树上的一个节点 \\(k\\) 和它所代表的区间 \\([l, r]\\), 我们维护出以 \\([l, r]\\) 为选取区间时的 \\(F(x), x \\in [1, r - l + 1]\\). 这个东西还是比较好弄的, 就是在合并子区间的时候用闵可夫斯基和维护一下即可. 闵可夫斯基和就相当于利用函数的凸性来加速背包合并的过程. 具体来说就是对两个子区间的凸包维护分别维护一个指针, 每次将指针所指向的两个值之和贡献给父区间的对应位置, 然后将变化量 \\(\\Delta\\) 更大的一个指针往后移动一位. 然后这里有个要注意的地方是, 如果左子区间选了最右边的一个元素, 右子区间也选了最左边的一个元素, 那么合并的时候可以认为少选择了一个区间. 所以我们对每个节点实际上要维护 4 个凸包, 分别表示左右端点的元素是否选择的情况下的 \\(F(x)\\). 这样我们就可以 \\(O(n \\log n)\\) 建出来一棵线段树. 对于查询的话, 我们还是按照凸优化的套路. 先把查询区间 \\([L, R]\\) 在线段树上对应的区间抠出来, 然后二分一个 \\(mid\\), 在每个区间的凸包上都二分找到斜率为 \\(mid\\) 的直线与该凸包的切点 (对于 4 个凸包都要找), 然后在对这些切点所对应的值做一个 01 背包, 求出最大值, 那么就找到了区间 \\([L, R]\\) 内 \\(F(x) - x \\cdot mid\\) 的最大值, 然后接着二分即可. 但是这样的话一次询问的复杂度是 \\(O(\\log^ n \\log value)\\) 的 (\\( O(\\log n)\\) 个线段树上的区间, 找切点一个 \\(\\log\\), 凸优化的二分又一个 \\(log\\)), 无法通过. 优化的话我们考虑使用 整体二分 把 在线段树区间的凸包上找切点 的复杂度优化掉. 我们对所有询问一起进行凸优化, 然后在整体二分进行到某一层的时候, 我们按照 \\(mid\\) 从大到小枚举每个询问 (这个 \\(mid\\) 指的是它在凸优化过程中二分出来的斜率 \\(mid\\), 而不是区间中点.), 然后把 在线段树区间的凸包上找切点 的二分改为 维护一个指针每次暴力移动. 然后因为对于同一个凸包来说, 斜率 \\(mid\\) 越小, 则它在该凸包上的切点位置越靠右 (画图理解), 所以对于线段树上每个区间的凸包, 它的指针的移动是单调的. 也就是说, 对于整体二分中的每一层, 线段树上所有指针的总移动次数是 \\(O(n \\log n)\\) 的, 那么总复杂度就是 \\(O(n \\log n \\log value)\\), 可以通过. 实现的时候由于线段树上的凸包需要用 \\(std::vector\\) 维护, 而这东西的常数又比较大, 所以不要在整体二分的每一层都对线段树上所有节点的凸包都移动, 而是只要访问到一个节点后移动它的凸包上的指针就行了. 还有凸优化二分的时候会出现凸包上三点贡献的情况, 然后按照上述的二分方法, 这时我们会将 \\(mid\\) 指向这些共线的点中最右边的那个点, 所以我们对于一个询问 \\((l, r, k)\\), 在所有 \\(x \\ge k\\) 的情况下 (\\(x\\) 就是切点横坐标) 都要覆盖答案的值. (因为二分进行到越后面, 得到的 \\(x\\) 就会越接近于 \\(k\\), 所以最后一个满足 \\(x \\ge k\\) 的 \\(x\\) 也就是最小的 \\(x\\), 也就是与 \\((k, F(k))\\) 共线的 \\((x, F(x))\\).) ","date":"2021-02-19","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/:2:0","tags":["OI","解题报告","数据结构","凸包","凸优化","闵可夫斯基和","CodeForces","300iq"],"title":"[解题报告][300iq Contest 2 H]Honorable Mention","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003cctime\u003e#include \u003ciostream\u003e#include \u003cvector\u003e #define pb push_back #define sz(x) (int)(x).size() #define mkp make_pair #define fi first #define se second using namespace std; typedef long long ll; const int _ = 35000 + 7; const int __ = 1e6 + 7; const ll inf = 1e18; int n, Q, a[_], tot; struct QUE { int l, r, k; int ans; } qu[_]; vector\u003cll\u003e f[__][2][2]; pair\u003cll, int\u003e g[2]; int pt[__][2][2], sz[__]; void upd(ll \u0026x, ll y) { x = max(x, y); } namespace SGT { #define mid ((l + r) \u003e\u003e 1) #define ls(k) (k \u003c\u003c 1) #define rs(k) (k \u003c\u003c 1 | 1) void Merge(int k, int len1, int len2, int a, int b, int c, int d) { int p1 = 1, p2 = 1; while (p1 \u003c= len1 and p2 \u003c= len2) { ll tmp = f[ls(k)][a][b][p1] + f[rs(k)][c][d][p2]; upd(f[k][a][d][p1 + p2], tmp); if (b and c) upd(f[k][a][d][p1 + p2 - 1], tmp); ll d1 = f[ls(k)][a][b][p1 + 1] - f[ls(k)][a][b][p1]; ll d2 = f[rs(k)][c][d][p2 + 1] - f[rs(k)][c][d][p2]; if (p1 != len1 and (p2 == len2 or d1 \u003e= d2)) ++p1; else ++p2; } } void Build(int k, int l, int r) { tot = max(tot, k), sz[k] = r - l + 1; for (int i = 0; i \u003c 2; ++i) for (int j = 0; j \u003c 2; ++j) { f[k][i][j].resize(r - l + 2); for (int t = 1; t \u003c= r - l + 1; ++t) f[k][i][j][t] = -inf; } if (l == r) return (void)(f[k][1][1][1] = a[l]); Build(ls(k), l, mid); Build(rs(k), mid + 1, r); for (int i = 0; i \u003c 2; ++i) { for (int j = 1; j \u003c= mid - l + 1; ++j) upd(f[k][i][0][j], max(f[ls(k)][i][0][j], f[ls(k)][i][1][j])); for (int j = 1; j \u003c= r - mid; ++j) upd(f[k][0][i][j], max(f[rs(k)][0][i][j], f[rs(k)][1][i][j])); } for (int a = 0; a \u003c 2; ++a) for (int b = 0; b \u003c 2; ++b) for (int c = 0; c \u003c 2; ++c) for (int d = 0; d \u003c 2; ++d) Merge(k, mid - l + 1, r - mid, a, b, c, d); } void Move(int k, int i, int j, int slope) { int p = pt[k][i][j]; while (p + 1 \u003c= sz[k] and slope \u003c= f[k][i][j][p + 1] - f[k][i][j][p]) ++p; pt[k][i][j] = p; } void Query(int k, int l, int r, int x, int y, int cst) { if (l \u003e= x and r \u003c= y) { pair\u003cll, int\u003e t0 = mkp(-1e18, 0), t1 = mkp(-1e18, 0); for (int i = 0; i \u003c 2; ++i) for (int j = 0; j \u003c 2; ++j) Move(k, i, j, cst); for (int i = 0; i \u003c 2; ++i) { for (int j = 0; j \u003c 2; ++j) { int p0 = pt[k][j][0], p1 = pt[k][j][1]; ll f0 = f[k][j][0][p0], f1 = f[k][j][1][p1]; if (i and j) { t0 = max(t0, mkp(g[i].fi + f0 - 1ll * (p0 - 1) * cst, g[i].se + p0 - 1)); t1 = max(t1, mkp(g[i].fi + f1 - 1ll * (p1 - 1) * cst, g[i].se + p1 - 1)); } t0 = max(t0, mkp(f0 - 1ll * p0 * cst, p0)); t1 = max(t1, mkp(f1 - 1ll * p1 * cst, p1)); t0 = max(t0, mkp(g[i].fi + f0 - 1ll * p0 * cst, g[i].se + p0)); t1 = max(t1, mkp(g[i].fi + f1 - 1ll * p1 * cst, g[i].se + p1)); } if (g[i].se) t0 = max(t0, g[i]); } g[0] = t0, g[1] = t1; return; } if (x \u003c= mid) Query(ls(k), l, mid, x, y, cst); if (y \u003e mid) Query(rs(k), mid + 1, r, x, y, cst); } #undef mid #undef ls #undef rs } pair\u003cpair\u003cint, int\u003e, int\u003e p[_], tmp1[_], tmp2[_], pn[_]; void Calc() { int l = -2e9, r = 2e9; int cnt = Q; for (int i = 1; i \u003c= Q; ++i) p[i] = mkp(mkp(l, r), i); while (cnt) { int cntn = 0; for (int i = 1; i \u003c= tot; ++i) pt[i][0][0] = pt[i][0][1] = pt[i][1][0] = pt[i][1][1] = 1; for (int i = cnt, j = cnt; i; i = j) { int t1 = 0, t2 = 0; while (j and p[j].fi.fi == p[i].fi.fi) --j; ll l = p[i].fi.fi, r = p[i].fi.se, mid = (l + r) \u003e\u003e 1; for (int k = i; k \u003e j; --k) { int x = p[k].se; g[0] = mkp(0, 0), g[1] = mkp(-1e18, 0); SGT::Query(1, 1, n, qu[x].l, qu[x].r, mid); auto tmp = max(g[0], g[1]); if (tmp.se \u003e= qu[x].k) { if (r \u003e mid) tmp2[++t2] = mkp(mkp(mid + 1, r), x); qu[x].ans = tmp.fi + 1ll * mid * qu[x].k; } else if (l \u003c mid) tmp1[++t1] = mkp(mkp(l, mid - 1), x); } for (int k = 1; k \u003c= t2; ++k) pn[++cntn] = tmp2[k]; for (int k = 1; k \u003c= t1; ++k) pn[++cntn] = tmp1[k]; } cnt = cntn; for (int i = 1; i \u003c= cnt; ++i) p[i] = pn[cnt - i + 1]; } } int main() { cin \u003e\u003e n \u003e\u003e Q; for (int i = 1; i \u003c= n; ++i) scanf(\"%d\", \u0026a[i]); for (int i = 1; i \u003c= Q; ++i) scanf(\"%d%d%d\", \u0026qu[i].l, \u0026qu[i].r, \u0026qu[i].k), qu[i].ans = -inf; SGT::Build(1, 1, n); Calc(); for (int i = 1; i \u003c= Q; ++i) print","date":"2021-02-19","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/:3:0","tags":["OI","解题报告","数据结构","凸包","凸优化","闵可夫斯基和","CodeForces","300iq"],"title":"[解题报告][300iq Contest 2 H]Honorable Mention","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/"},{"categories":["OI","解题报告"],"content":"Statement 题面 \\(n\\) 个灯泡和 \\(n\\) 个房间匹配, 只有灯泡权值比房间权值大才能匹配, 可以将 \\(k\\) 个灯泡换成权值任意的灯泡, 求存在完美匹配的灯泡总权值的最小值. ","date":"2021-02-17","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/:1:0","tags":["OI","解题报告","模拟费用流","bzoj"],"title":"[解题报告][bzoj3728][bzoj3728]Zarowki","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/"},{"categories":["OI","解题报告"],"content":"Solution 首先直觉上肯定是要使灯泡和房间的权值之差越小越好. 那么可以发现一个性质, 如果我们要换灯泡, 则一定会将其权值设为某个房间的权值. 那么我们实际上只要找 \\(n - k\\) 个匹配, 然后每个匹配的代价为灯泡和房间的权值之差, 最后答案再加上所有房间的权值之和即可. 考虑怎么建图. 要注意用到 \"只有灯泡权值比房间权值大才能匹配\" 这个性质/条件. 把所有权值(包括灯泡和房间)离散化, 然后从小往大连容量为 \\(\\inf\\), 权值为 \\(w_{i + 1} - w_i\\) 的边, 然后从 \\(S\\) 连向房间对应的权值, 从灯泡对应的权值连向 \\(T\\), 那么在这张图上跑费用流即可得到答案. 发现这里所有边的方向都是一致的, 所以反边是没有用的, 所以我们只需要用堆维护一下权值相邻的房间和灯泡中权值之差的最小值, 每次把最小值的一对灯泡和房间取出来并删除. 这个显然删除操作可以用 \\(\\mathrm{set}\\) 维护, 但是时限只有 1s, 在 darkbzoj 上会 T. 而实际上把 \"删除\" 看做 \"区间合并\", 然后用并查集维护就行了. (这个并查集的细节最好先想清楚.) ","date":"2021-02-17","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/:2:0","tags":["OI","解题报告","模拟费用流","bzoj"],"title":"[解题报告][bzoj3728][bzoj3728]Zarowki","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/"},{"categories":["OI","解题报告"],"content":"Code #include \u003calgorithm\u003e#include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cset\u003e #define ins insert #define ers erase #define mkp make_pair #define fi first #define se second using namespace std; typedef long long ll; const int _ = 1e6 + 7; int n, K, fa[_], sz[_]; pair\u003cint, int\u003e a[_]; ll ans; priority_queue\u003cpair\u003cint, int\u003e\u003e h; int gi() { int x = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x \u003c\u003c 3) + (x \u003c\u003c 1) + c - '0', c = getchar(); return x; } int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); } int main() { cin \u003e\u003e n \u003e\u003e K; for (int i = 1; i \u003c= n; ++i) a[i] = mkp(gi(), 1); for (int i = 1, w; i \u003c= n; ++i) w = gi(), ans += w, a[n + i] = mkp(w, 0); sort(a + 1, a + 2 * n + 1); a[0].se = 1, a[2 * n + 1].se = 0; for (int i = 1; i \u003c= 2 * n + 1; ++i) { fa[i] = i, sz[i] = 1; if (a[i].se == 0 and a[i + 1].se == 1) h.push(mkp(a[i].fi - a[i + 1].fi, i)); } for (int cnt = 1; cnt \u003c= n - K; ++cnt) { if (h.empty()) { puts(\"NIE\"); exit(0); } auto t = h.top(); h.pop(); ans += -t.fi; int x = t.se, y = Find(x + 1); assert(a[x].se == 0 and a[y].se == 1); assert(x \u003e= 1 and y \u003c= 2 * n); int tx = x - sz[x], ty = Find(y + 1); if (a[tx].se == 0 and a[ty].se == 1) h.push(mkp(a[tx].fi - a[ty].fi, tx)); fa[x] = y, sz[y] += sz[x]; fa[y] = ty, sz[ty] += sz[y]; } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-02-17","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/:3:0","tags":["OI","解题报告","模拟费用流","bzoj"],"title":"[解题报告][bzoj3728][bzoj3728]Zarowki","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/"},{"categories":["OI","解题报告"],"content":"Foreword 昨天晚上讲题的时候看到 \\(\\mathrm{M\\color{red}{\\_sea}}\\) 巨巨在写烷基计数, 正好我之前在搞 Burnside 引理, 于是也找来做了. 由于不清楚难度顺序, 就先开了「烷烃计数」, 想试着往之前有色图那个做法上套, 结果想了一个多小时一点思路都没有. (不过话说从这个数据范围应该就看得出做法明显不一样吧…) 后来 \\(\\mathrm{M\\color{red}{\\_sea}}\\) 给我指了条明路, 让我先去做「烷基计数」. 一语点醒梦中人, 于是就有了这篇解题报告. (三倍经验警告) ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:1:0","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"烷基计数 ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:2:0","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Statement [loj6538]烷基计数 加强版 加强版 求碳原子个数为 \\(n\\) 的烷基的同分异构体的数量. \\(n \\le 10^5\\). ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:2:1","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Solution 「烷基计数」比「烷烃计数」简单的地方在于, 「烷基计数」是有根的, 那么我们就可以考虑从根开始往下递归. 首先, 考虑怎么处理根的儿子的同构情况. 这里我们直接使用 Burnside 引理, 便把无标号的子节点变成有标号了, 然后再对每个置换算出它所对应的染色方案数量即可 (即不动点方案). 因为这里根只有 \\(3\\) 个子节点 (子节点为空的话就看做该子树的大小为 \\(0\\)), 所以总共只有 \\(3! = 6\\) 中置换, 手动把每种置换的不动点数量算出来即可. 具体来说, 设 \\(f_i\\) 表示大小为 \\(i\\) 的烷基的同分异构体的数量, 则有 \\[ f_i = \\frac{1}{6} (2[3 \\mid (i - 1)]f_{\\frac{i - 1}{3}} + 3\\sum_{j = 0}^{\\lfloor \\frac{i - 1}{2} \\rfloor} f_jf_{i - 1 - 2j} + \\sum_{j = 0}^{i - 1} \\sum_{k = 0}^{i - 1 - j} f_jf_kf_{i - 1 - j - k}) \\] 这样的话就可以得到一个 \\(O(n^3)\\) 的暴力. 下面考虑使用生成函数优化. (由于本人才疏学浅并且对生成函数的应用极其不熟练, 所以以下内容借鉴于这篇博客). (怎么想都想不到可以把指数放在 x 上) 设 \\(F(x) = \\sum_{i \\ge 0} f_ix^i\\). 那么上面的式子可以写成 \\[ F(x) = 1 + \\frac{1}{6}x[2F(x^3) + 3F(x^2)F(x) + F(x)^3] \\] (这里不要像我一样看到 \\(F(x^3)\\) 和 \\(F(x^2)\\) 这两个东西懵逼了, 实际上把它们看做两个另外的函数就可以了.) 这个式子可以分治FFT, 也可以牛顿迭代. 分治 FFT 的做法比较显然, 下面大致描述一下牛顿迭代的做法. 首先设 \\(G(F(x)) = 1 + \\frac{1}{6}x[2F(x^3) + 3F(x^2)F(x) + F(x)^3] - F(x)\\). 然后按照牛顿迭代的套路, 假设已经求出了 \\(F_0(x)\\) 满足 \\(G(F_0(X)) \\equiv 0 \\pmod{x^{\\frac{n}{2}}}\\), 现在要求 \\(F(x)\\) 满足 \\(G(F(x)) \\equiv 0 \\pmod{x^n}\\) \\[ F(x) = F_0(x) - \\frac{G(F_0(x))}{G'(F_0(x))} \\] 手动把 \\(G'(F_0(x))\\) 化一下即可. 实现的时候可以分子分母同乘一个常数, 就可以不用乘那么多逆元了. 时间复杂度为 \\(O(n\\log n)\\). 实现的时候注意清空会导致循环卷积的位置. ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:2:2","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = (1 \u003c\u003c 20) + 7; const int mod = 998244353; int Pw(int a, int p) { int res = 1; while (p) { if (p \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; p \u003e\u003e= 1; } return res; } namespace Poly { int tot, num[_], pwrt[_], inv[_], a[_], b[_]; unsigned long long q[_]; void Init(int n) { tot = 1; while (tot \u003c n + n) tot \u003c\u003c= 1; inv[1] = 1; for (int i = 2; i \u003c= tot; ++i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; pwrt[0] = 1, pwrt[1] = Pw(3, (mod - 1) / tot); for (int i = 2; i \u003c= tot; ++i) pwrt[i] = 1ll * pwrt[i - 1] * pwrt[1] % mod; } void NTT(int *f, bool ty, int t = tot) { for (int i = 0; i \u003c t; ++i) { num[i] = (num[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) ? t \u003e\u003e 1 : 0); q[i] = f[num[i]]; } for (int len = 2; len \u003c= t; len \u003c\u003c= 1) { int gap = len \u003e\u003e 1, d = tot / len; for (int i = 0; i \u003c t; i += len) for (int j = 0; j \u003c gap; ++j) { int tmp = q[i + j + gap] * pwrt[ty ? tot - j * d : j * d] % mod; q[i + j + gap] = q[i + j] - tmp + mod; q[i + j] = q[i + j] + tmp; } } for (int i = 0; i \u003c t; ++i) f[i] = q[i] * (ty ? inv[t] : 1) % mod; } void Mul(int *h, int *f, int *g, int t) { memcpy(a, f, t \u003c\u003c 2), memcpy(b, g, t \u003c\u003c 2), memset(h, 0, t \u003c\u003c 2); NTT(a, 0, t), NTT(b, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * a[i] * b[i] % mod; NTT(h, 1, t); } void Inv(int *h, int *f, int Len) { memset(a, 0, Len \u003c\u003c 3), memset(b, 0, Len \u003c\u003c 3); memcpy(b, f, sizeof b); memset(h, 0, Len \u003c\u003c 3); h[0] = Pw(b[0], mod - 2), a[0] = b[0], a[1] = b[1]; for (int len = 2, t = 4; len \u003c= Len; len \u003c\u003c= 1, t \u003c\u003c= 1) { NTT(a, 0, t), NTT(h, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * h[i] * (2 - 1ll * h[i] * a[i] % mod + mod) % mod; NTT(h, 1, t); memcpy(a, b, t \u003c\u003c 2), memset(h + len, 0, len \u003c\u003c 2); } } } int n, F[_], H[_], A[_], B[_], T0[_], T1[_], T2[_]; int main() { cin \u003e\u003e n; Poly::Init(2 * (n + 1)); H[0] = A[0] = B[0] = 1; for (int len = 2, t = 4; len \u003c= 2 * (n + 1); len \u003c\u003c= 1, t \u003c\u003c= 1) { memset(T0 + len, 0, len \u003c\u003c 2); for (int i = 0; i \u003c len; ++i) T0[i] = 2ll * A[i] % mod; Poly::Mul(T1, B, H, t); for (int i = 0; i \u003c len; ++i) T0[i] = (T0[i] + 3ll * T1[i] % mod) % mod; Poly::Mul(T2, H, H, t), Poly::Mul(T1, T2, H, t); for (int i = len - 1; i; --i) T0[i] = (T0[i - 1] + T1[i - 1]) % mod; T0[0] = 6; for (int i = 0; i \u003c len / 2; ++i) T0[i] = (T0[i] - 6ll * H[i] % mod + mod) % mod; for (int i = len - 1; i; --i) T1[i] = 3ll * (B[i - 1] + T2[i - 1]) % mod; T1[0] = mod - 6; Poly::Inv(T1, T1, len); memset(T1 + len, 0, len \u003c\u003c 2); Poly::Mul(T0, T0, T1, t); for (int i = 0; i \u003c len; ++i) H[i] = (H[i] - T0[i] + mod) % mod, A[i] = B[i] = 0; for (int i = 0; i \u003c len * 2 / 3; ++i) A[i * 3] = H[i]; for (int i = 0; i \u003c len; ++i) B[i * 2] = H[i]; } cout \u003c\u003c H[n] \u003c\u003c endl; return 0; } ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:2:3","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"烯烃计数 ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:3:0","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"statement [luoguP6597]烯烃计数 求出碳原子数量为 \\(2 \\sim n\\) 的 单烯烃 的同分异构体数量. \\( n \\le 10^5 \\). ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:3:1","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Solution 容易想到把碳碳双键看做根, 而碳碳双键两边的碳原子所连出去的东西其实就是若干个烷基, 所以先按照上面的方法算出烷基个数. 然后碳碳双键两边的碳原子只有两个儿子, 那么也与上面类似, 对大小为 \\(2\\) 的置换讨论一下, 列出式子, 然后生成函数乘一下即可. (需要注意这里 \\(x^0\\) 的系数要为 \\(0\\), 因为碳碳双键两边必须要接碳原子.) 然后对于这个碳碳双键, 可以把它看做一个点, 然后也是用 Burnside 引理按照上面的做法弄一下就好了. 时间复杂度为 \\(O(n \\log n)\\). (其实和烷基计数没什么区别, 不过可以用来水水题量.) ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:3:2","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = (1 \u003c\u003c 20) + 7; const int mod = 998244353; int Pw(int a, int p) { int res = 1; while (p) { if (p \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; p \u003e\u003e= 1; } return res; } namespace Poly { int tot, num[_], pwrt[_], inv[_], a[_], b[_]; unsigned long long q[_]; void Init(int n) { tot = 1; while (tot \u003c n + n) tot \u003c\u003c= 1; inv[1] = 1; for (int i = 2; i \u003c= tot; ++i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; pwrt[0] = 1, pwrt[1] = Pw(3, (mod - 1) / tot); for (int i = 2; i \u003c= tot; ++i) pwrt[i] = 1ll * pwrt[i - 1] * pwrt[1] % mod; } void NTT(int *f, bool ty, int t = tot) { for (int i = 0; i \u003c t; ++i) { num[i] = (num[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) ? t \u003e\u003e 1 : 0); q[i] = f[num[i]]; } for (int len = 2; len \u003c= t; len \u003c\u003c= 1) { int gap = len \u003e\u003e 1, d = tot / len; for (int i = 0; i \u003c t; i += len) for (int j = 0; j \u003c gap; ++j) { int tmp = q[i + j + gap] * pwrt[ty ? tot - j * d : j * d] % mod; q[i + j + gap] = q[i + j] - tmp + mod; q[i + j] = q[i + j] + tmp; } } for (int i = 0; i \u003c t; ++i) f[i] = q[i] * (ty ? inv[t] : 1) % mod; } void Mul(int *h, int *f, int *g, int t) { memcpy(a, f, t \u003c\u003c 2), memcpy(b, g, t \u003c\u003c 2), memset(h, 0, t \u003c\u003c 2); NTT(a, 0, t), NTT(b, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * a[i] * b[i] % mod; NTT(h, 1, t); } void Inv(int *h, int *f, int Len) { memset(a, 0, Len \u003c\u003c 3), memset(b, 0, Len \u003c\u003c 3); memcpy(b, f, sizeof b); memset(h, 0, Len \u003c\u003c 3); h[0] = Pw(b[0], mod - 2), a[0] = b[0], a[1] = b[1]; for (int len = 2, t = 4; len \u003c= Len; len \u003c\u003c= 1, t \u003c\u003c= 1) { NTT(a, 0, t), NTT(h, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * h[i] * (2 - 1ll * h[i] * a[i] % mod + mod) % mod; NTT(h, 1, t); memcpy(a, b, t \u003c\u003c 2), memset(h + len, 0, len \u003c\u003c 2); } } } int n, F[_], G[_], H[_], A[_], B[_], T0[_], T1[_], T2[_], inv2 = 499122177; int main() { cin \u003e\u003e n; Poly::Init(2 * (n + 1)); H[0] = A[0] = B[0] = 1; int len, t; for (len = 2, t = 4; len \u003c= 2 * (n + 1); len \u003c\u003c= 1, t \u003c\u003c= 1) { memset(T0 + len, 0, len \u003c\u003c 2); for (int i = 0; i \u003c len; ++i) T0[i] = 2ll * A[i] % mod; Poly::Mul(T1, B, H, t); for (int i = 0; i \u003c len; ++i) T0[i] = (T0[i] + 3ll * T1[i] % mod) % mod; Poly::Mul(T2, H, H, t), Poly::Mul(T1, T2, H, t); for (int i = len - 1; i; --i) T0[i] = (T0[i - 1] + T1[i - 1]) % mod; T0[0] = 6; for (int i = 0; i \u003c len / 2; ++i) T0[i] = (T0[i] - 6ll * H[i] % mod + mod) % mod; for (int i = len - 1; i; --i) T1[i] = 3ll * (B[i - 1] + T2[i - 1]) % mod; T1[0] = mod - 6; Poly::Inv(T1, T1, len); memset(T1 + len, 0, len \u003c\u003c 2); Poly::Mul(T0, T0, T1, t); for (int i = 0; i \u003c len; ++i) H[i] = (H[i] - T0[i] + mod) % mod, A[i] = B[i] = 0; for (int i = 0; i \u003c len * 2 / 3; ++i) A[i * 3] = H[i]; for (int i = 0; i \u003c len; ++i) B[i * 2] = H[i]; } len \u003e\u003e= 1, t \u003e\u003e= 1; Poly::Mul(G, H, H, t); memset(G + len, 0, len \u003c\u003c 2); for (int i = len - 1; i; --i) G[i] = 1ll * inv2 * (B[i - 1] + G[i - 1]) % mod; G[0] = 0; memset(B, 0, len \u003c\u003c 2); for (int i = 0; i \u003c len; ++i) B[i * 2] = G[i]; Poly::Mul(F, G, G, t); for (int i = 0; i \u003c len; ++i) F[i] = 1ll * inv2 * (B[i] + F[i]) % mod; for (int i = 2; i \u003c= n; ++i) printf(\"%d\\n\", F[i]); return 0; } ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:3:3","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"烷烃计数 ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:4:0","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Statement luoguP6598]烷烃计数 求出碳原子数量为 \\(n\\) 的烷烃的同分异构体数量. \\(n \\le 10^5\\). ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:4:1","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Solution. 在经历了「烷基计数」和「烯烃计数」的洗礼后, 我突然领悟了 \\(\\mathrm{M\\color{red}{\\_sea}}\\) 看似漫不经心实际别有深意地 说出的一个词: 「重心」. 现在, 烷烃计数难搞的地方只在于它没有根, 那么我们要是能对一个烷烃找到一个唯一的根, 那么问题就迎刃而解了. 而「重心」就是一个经典的选择. 对于 \\(n\\) 为奇数的情况, 由于重心只会有一个, 所以直接把重心作为根即可. 具体来说, 就是先求出烷基个数, 在最后合并的时候, 根节点有 \\(4\\) 个儿子, 并且每一个子树的大小都小于 \\(\\lceil \\frac{n}{2} \\rceil \\). 那么我们对 \\(4! = 24\\) 个置换讨论一下即可. 当然可能会有点麻烦. 对于 \\(n\\) 为偶数的情况, 若重心有一个子树的大小为 \\( \\frac{n}{2} \\), 则这时会有两个重心, 这个烷烃就会被统计两次. (可以画个图理解.) 所以我们限制每个子树大小都小于 \\( \\frac{n}{2} \\), 然后按上面 \\(n\\) 为奇数的情况统计. 而对于有两个重心的情况, 我们可以把两个重心之间那条边看做一个点, 然后对 \\(2! = 2\\) 个置换讨论一下即可. (跟上面烯烃计数的情况差不多.) 复杂度为 \\(O(n \\log n)\\). ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:4:2","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = (1 \u003c\u003c 20) + 7; const int mod = 998244353; int Pw(int a, int p) { int res = 1; while (p) { if (p \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; p \u003e\u003e= 1; } return res; } namespace Poly { int tot, num[_], pwrt[_], inv[_], a[_], b[_]; unsigned long long q[_]; void Init(int n) { tot = 1; while (tot \u003c n + n) tot \u003c\u003c= 1; inv[1] = 1; for (int i = 2; i \u003c= tot; ++i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; pwrt[0] = 1, pwrt[1] = Pw(3, (mod - 1) / tot); for (int i = 2; i \u003c= tot; ++i) pwrt[i] = 1ll * pwrt[i - 1] * pwrt[1] % mod; } void NTT(int *f, bool ty, int t = tot) { for (int i = 0; i \u003c t; ++i) { num[i] = (num[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) ? t \u003e\u003e 1 : 0); q[i] = f[num[i]]; } for (int len = 2; len \u003c= t; len \u003c\u003c= 1) { int gap = len \u003e\u003e 1, d = tot / len; for (int i = 0; i \u003c t; i += len) for (int j = 0; j \u003c gap; ++j) { int tmp = q[i + j + gap] * pwrt[ty ? tot - j * d : j * d] % mod; q[i + j + gap] = q[i + j] - tmp + mod; q[i + j] = q[i + j] + tmp; } } for (int i = 0; i \u003c t; ++i) f[i] = q[i] * (ty ? inv[t] : 1) % mod; } void Mul(int *h, int *f, int *g, int t = tot) { memcpy(a, f, t \u003c\u003c 2), memcpy(b, g, t \u003c\u003c 2), memset(h, 0, t \u003c\u003c 2); NTT(a, 0, t), NTT(b, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * a[i] * b[i] % mod; NTT(h, 1, t); } void Inv(int *h, int *f, int Len) { memset(a, 0, Len \u003c\u003c 3), memset(b, 0, Len \u003c\u003c 3); memcpy(b, f, sizeof b); memset(h, 0, Len \u003c\u003c 3); h[0] = Pw(b[0], mod - 2), a[0] = b[0], a[1] = b[1]; for (int len = 2, t = 4; len \u003c= Len; len \u003c\u003c= 1, t \u003c\u003c= 1) { NTT(a, 0, t), NTT(h, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * h[i] * (2 - 1ll * h[i] * a[i] % mod + mod) % mod; NTT(h, 1, t); memcpy(a, b, t \u003c\u003c 2), memset(h + len, 0, len \u003c\u003c 2); } } } int n, m, F[_], G[_], H[_], A[_], B[_], C[_], T0[_], T1[_], T2[_], inv24 = 291154603; int main() { cin \u003e\u003e n; m = (n \u0026 1) ? n / 2 + 1 : n / 2; Poly::Init(2 * (n + 1)); H[0] = A[0] = B[0] = 1; int len, t; for (len = 2, t = 4; len \u003c= 2 * (m + 1); len \u003c\u003c= 1, t \u003c\u003c= 1) { memset(T0 + len, 0, len \u003c\u003c 2); for (int i = 0; i \u003c len; ++i) T0[i] = 2ll * A[i] % mod; Poly::Mul(T1, B, H, t); for (int i = 0; i \u003c len; ++i) T0[i] = (T0[i] + 3ll * T1[i] % mod) % mod; Poly::Mul(T2, H, H, t), Poly::Mul(T1, T2, H, t); for (int i = len - 1; i; --i) T0[i] = (T0[i - 1] + T1[i - 1]) % mod; T0[0] = 6; for (int i = 0; i \u003c len / 2; ++i) T0[i] = (T0[i] - 6ll * H[i] % mod + mod) % mod; for (int i = len - 1; i; --i) T1[i] = 3ll * (B[i - 1] + T2[i - 1]) % mod; T1[0] = mod - 6; Poly::Inv(T1, T1, len); memset(T1 + len, 0, len \u003c\u003c 2); Poly::Mul(T0, T0, T1, t); for (int i = 0; i \u003c len; ++i) H[i] = (H[i] - T0[i] + mod) % mod, A[i] = B[i] = 0; for (int i = 0; i \u003c len * 2 / 3; ++i) A[i * 3] = H[i]; for (int i = 0; i \u003c len; ++i) B[i * 2] = H[i]; } if (t \u003e Poly::tot) t \u003e\u003e= 1, len \u003e\u003e= 1; memset(T0, 0, sizeof T0), memset(A, 0, sizeof A), memset(B, 0, sizeof B), memset(C, 0, sizeof C); memcpy(T0, H, m \u003c\u003c 2); for (int i = 0; i \u003c len / 2; ++i) A[i * 4] = T0[i]; for (int i = 0; i \u003c len * 2 / 3; ++i) B[i * 3] = T0[i]; for (int i = 0; i \u003c len; ++i) C[i * 2] = T0[i]; memset(A + len, 0, len \u003c\u003c 2), memset(B + len, 0, len \u003c\u003c 2), memset(C + len, 0, len \u003c\u003c 2); for (int i = 0; i \u003c len; ++i) F[i] = 6ll * A[i] % mod; Poly::Mul(T1, B, T0, t); for (int i = 0; i \u003c len; ++i) F[i] = (F[i] + 8ll * T1[i] % mod) % mod; Poly::Mul(T1, C, C, t); for (int i = 0; i \u003c len; ++i) F[i] = (F[i] + 3ll * T1[i] % mod) % mod; Poly::Mul(T1, T0, T0, t), memset(T1 + len, 0, len \u003c\u003c 2), Poly::Mul(T1, T1, C); for (int i = 0; i \u003c len; ++i) F[i] = (F[i] + 6ll * T1[i] % mod) % mod; Poly::Mul(T1, T0, T0, t), memset(T1 + len, 0, len \u003c\u003c 2), Poly::Mul(T1, T1, T1, t); for (int i = 0; i \u003c len; ++i) F[i] = (F[i] + T1[i]) % mod; for (int i = len - 1; i; --i) F[i] = 1ll * inv24 * F[i - 1] % mod; F[0] = 1; if (n \u0026 1) printf(\"%d\\n\", F[n]); else { int ans = 1ll * (H[n / 2] + 1ll * H[n / 2] * H[n / 2] % mod) * Pw(2, mod - 2) % mod; printf(\"%d\\n\", (ans + F[n]) % mod); } return 0; } ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:4:3","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","学习笔记"],"content":"一些不太清楚的问题 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:1:0","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"一 在分治FFT求 \\( \\Pi_{j} (1 - a_jy) \\) 的时候，由于递归到底的时候要为 \\( 1 - a_jy \\) 留两个位置，所以最终会导致求出来的数组是 tot 级别的，而实际上 \\( \\Pi_{j} (1 - a_jy) \\) 是 \\( \\frac{tot}{2} \\) 级别的，造成了浪费，而且感觉不太优美 答：看了一份题解的代码，貌似也没有对这方面的处理，那也就只能这样写了。 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:1:1","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"二 鸡贼课件里说所谓 “转置原理” 就是 \\( f(x) \\times g(x) \\cdot h(x) \\Leftrightarrow g(x) \\cdot h(x) \\times f(\\frac{1}{x}) \\) ，但这个下标问题有点迷，还得推一下 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:1:2","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"gzy课件 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:2:0","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"一 关于鸡贼写的那个\\( f(x) \\times g(x) \\cdot h(x) \\Leftrightarrow g(x) \\cdot h(x) \\times f(\\frac{1}{x}) \\)，如果直接按这种形式写的话貌似会扯到循环卷积，就比较烦。 目前我只知道如果把 \\( f(\\frac{1}{x}) \\) 直接看做 \\(f_r(x)\\) （对前 \\( 0 \\sim n - 1 \\) 项翻转）的话，可以把点积转化为卷积的 \\( x^{n-1} \\) 项系数，不知道其他用法会不会对这个翻转的要求不一样。 upd: 推了一波式子，并实验了一波，得到结论其实是 \\( A(x)B(x) \\cdot C(x) = Ar(x) \\cdot B(x)Cr(x) = Br(x) \\cdot A(x)Cr(x) = A(x) \\cdot (B(x)Cr(x))r \\) 注意 ： 不是 \\(Ar(x) \\cdot Br(x)C(x)\\)，究其原因在于进行减法卷积时，若将两个多项式互换，最终得到的结果会不一样。 但对于 \\(A(x)B(x) \\cdot C(x)D(x)\\) 这种形式除了先把 \\(C,D\\) 卷起来之外暂时没想到什么更好的方法，因为要扯到减法卷积。 挖个坑 点积本质上就是减法卷积的0次项系数，所以推一下式子可以得到加法卷积和减法卷积的转换律，不过好像想不到什么应用，感觉有点鸡肋？ 减法卷积：设 \\(A(x) \\circ B(x) = \\sum_{i = 0}^{n-1}x^i\\sum_{j = i}^{n-1} a_jb_{j-i}\\)，则 \\(A(x) \\circ B(x) = (Ar(x)B(x))r\\) （猜的，待验证） ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:2:1","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"二 突然感觉鸡贼写的有点nb，居然能把转置抽象成一个纯多项式的东西？ 如果能把多项式操作和矩阵变换联系起来，估计就比较好理解了。 点积好像还行，但卷积怎么转化为矩阵？ ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:2:2","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"转置原理的简单介绍 笔记 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:3:0","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"线性算法 一个 \\( n \\times n \\) 常数矩阵 \\(A\\) 左乘一个 \\( n \\times 1 \\) 的变量向量 \\( a\\)，得到 \\( b \\) 的算法 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:3:1","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"转置 对于线性算法 \\( b = Aa \\)，称 \\( b' = A^Ta \\) 为它的转置算法。（ \\(A^T\\) 表示矩阵 \\(A\\) 的转置，就是沿主对角线翻转） 其实我感觉把向量换成矩阵也成立 定理： 设 \\( A = E_1 E_2 E_3 \\cdots E_k \\) 则 \\( A^T = E_k^T E_{k-1}^T E_{k-2}^T \\cdots E_1^T \\) 其中 \\(E\\) 为初等矩阵 然后如果你把矩乘换回普通操作（就是普通 C++ 语句），就相当于把所有操作反着做一遍，什么参数传入改为返回，函数调用顺序反过来…… 有种看 信条 的感觉 5-2 复合 简单函数 4 没看懂 一元函数的复合可以用复合的结合律简化运算 但二元函数怎么办？ 二元函数 \\( F(x,y) \\) 左乘一个向量 \\( b(y) \\)，\\( y^i \\) 没有什么实际意义，只是相当于建立了一个对应关系，从而得到每一个 \\( x^i \\) 的系数。而复合函数 \\( q'(sp(y)) \\) 也是建立了一个对应关系，如果我们把复合函数的对应关系一层层扒下来，那么就可以简化运算。 设我们现在要求 \\( f(p(x)q(y)) \\cdot b(y) \\)，然后 \\( q(y) \\) 能写成 \\(q'(sp(y))\\) 的形式，其中 \\( sp(y) \\) 是一个简单函数。 我们考虑把 \\(b(y)\\) 换个基，变成 \\(b'(sp(y))\\)，然后就相当于把 \\(sp(y)\\) 扒出来了。 考虑如何求 \\(b'\\)。 设 \\(sp^{-1}(y)\\) 为 \\(sp(y)\\) 的复合逆，设 \\(t = sp(y)\\)， 则 \\(y = sp^{-1}(sp(y)) = sp^{-1}(t) \\)， 那么把 \\(y = sp^{-1}(t)\\) 带入 \\(b(y)\\) 就可以得到 \\(b(y) = b(sp^{-1}(t))\\)，所以 \\(b'(sp(y)) = b'(t) = b(sp^{-1}(t)) \\)，也即 \\(b' = b \\circ sp^{-1}\\)。 所以原式就可以变为 \\(f(p(x)q'(t)) \\cdot b'(t) \\)，然后再把 \\(q'(t)\\) 一层一层按照上面的过程拆下去，直到得到一个 \\(q'_{final}(z) = z\\)， 那么原式为 \\(f(p(x)q'_{final}(z)) \\cdot b''(z) \\)， 展开后就是 \\( \\begin{aligned} f(p(x)q'_{final}(z)) \\cdot b''(z) \u0026= (\\sum_{i} f_i p(x)^i z^i) \\cdot (\\sum_{i}b''_{i} z^i) \\\\ \u0026= \\sum_{i} f_i b''_{i}p(x)^i z^i \\\\ \\end{aligned} \\) 所以可以先把 \\(f\\) 和 \\(b''\\) 点积起来，设 \\(f'(t) = f(t) \\cdot b(t) \\)，之后的操作就是 \\( f' \\circ p \\)，然后由于 \\(p\\) 又是由若干个简单函数复合而成，所以可以根据复合的结合律来一层层复合。 回到更普通的形式，即 \\(u(x)v(y)f(p(x)q(y)) \\cdot b(y) \\)， 对于 \\(v(y)\\)，我们使用 \\(A(x)B(x) \\cdot C(x) = A(x) \\cdot (B(x)Cr(x))r\\) 的技巧，先把 \\(v(y)\\) 挪到右边，然后就变为了 \\(u(x)v(y)f(p(x)q(y)) \\cdot b'(y) \\)， 接着再按照上面的步骤，最后得到 \\(u(x)(\\sum_{i} f_i b''_{i}p(x)^i z^i)\\)，那么就先把后面那项求出来，然后再卷一次就OK了 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:3:2","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"DFT的转置 尝试用转置方法写了发DFT，为啥转置后跑得飞快啊？？？ UOJ上普通写法总时间2000ms左右，转置写法只要不到700ms。。。 感觉运算量没差吧？？？？？ 但为啥洛谷上又没啥差别。。。。 结果只是刚刚UOJ抽风了。。。。 由于转置方法是分治算完后二进制翻转，而原方法是分治算之前二进制翻转，所以如果你DFT用转置方法，IDFT用原方法，就可以少两个二进制翻转的过程，稍微能快那么一丢丢。 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:3:3","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"xgzc的课件 那个 “复合矩阵” 看得我一脸懵逼，没太懂 \\(COM(F)_{i,j} = [x^j]F(x^i)\\) 是啥意思 然后从 \\( A(x,y) = \\sum_{i=0}^{n-1}g(x)^i f_i h(y)^i \\) 到 \\( A = COM^T(g)I(f)COM(h) \\) 也没看懂 没事了, 原来是他把 \\(F(x)^i\\) 写成了 \\(F(x^i)\\) ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:4:0","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 一个点数为 \\(n\\) 的环 (项链), 每个点可以被染成黑色或白色. 染色要求为: 恰好有 \\(m\\) 个点被染为黑色, 且不存在长度 \\(\u003ek\\) 的黑色连续串. 考虑旋转同构, 求本质不同的的染色方案数. \\( m \\le n \\le 10^5, k \\le 10^5\\). ","date":"2021-02-08","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/:1:0","tags":["解题报告","luogu","Burnside引理","数学","计数","容斥"],"title":"[解题报告][luogu4916]魔力环","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/"},{"categories":["OI","解题报告"],"content":"Solution 这里旋转就相当于置换, 本质不同的的染色方案就相当于轨道数. 那么使用 Burnside 引理, 把轨道数转化为置换的不动点数量. 这里总共有 \\(n\\) 个置换, 每个置换都形如 \\[ \\begin{Bmatrix} 1 \u0026 2 \u0026 3 \u0026 \\cdots \u0026 n - i + 1 \u0026 n - i \u0026 \\cdots \u0026 n - 1 \u0026 n \\\\ i \u0026 i + 1 \u0026 i + 2 \u0026 \\cdots \u0026 n \u0026 1 \u0026 \\cdots \u0026 i - 2 \u0026 i - 1 \\end{Bmatrix} \\] 那么第 \\(i\\) 个置换的每个循环的长度为 \\( \\mathrm{lgt} = \\frac{lcm(i, n)}{i} = \\frac{n}{\\gcd(i, n)} \\), 循环的数量为 \\( \\mathrm{num} = \\gcd(i, n) \\). 所以 \\(n\\) 就会被分成 \\(\\mathrm{lgt}\\) 段由 \\(\\mathrm{num}\\) 个属于不同循环的点组成的区间 (是的这里没打错). 那么对这个 \\(n\\) 元环的染色就相当于对这个 \\(\\mathrm{num}\\) 元环的染色. (因为每个循环中的颜色都必须相同.) 那么我们设 \\( g(i, j) \\) 为给 \\(i\\) 元环染上 \\(m\\) 个黑点的合法方案数 (不考虑循环同构). 那么我们要求的就是 (这里我们默认 \\( \\frac{n}{\\gcd(i, n)} \\mid m \\).) \\[ \\frac{1}{n} \\sum_{i = 1}^n g(\\gcd(i, n), \\frac{m}{n / \\gcd(i, n)}) \\] 改为枚举 \\(\\gcd\\) (默认 \\( d \\mid n \\)) \\[ \\begin{aligned} \\frac{1}{n} \\sum_{i = 1}^n g(\\gcd(i, n), \\frac{m}{n / \\gcd(i, n)}) \u0026= \\frac{1}{n} \\sum_{d = 1}^n g(d, \\frac{m}{n / d}) \\sum_{i = 1}^{\\frac{n}{d}} [\\gcd(\\frac{n}{d}, i) = 1] \\\\ \u0026= \\frac{1}{n} \\sum_{d = 1}^n g(d, \\frac{m}{n / d}) \\varphi(\\frac{n}{d}) \\end{aligned} \\] 那么现在考虑怎么求 \\(g(d, \\frac{m}{n / d})\\). 环不好弄, 那么我们枚举最后一段黑色连续段和第一段黑色连续段的长度之和, 断环为链. 然后因为黑点和白点的数量是固定的, 所以我们可以把黑色连续段看做把若干个黑点放在白点之间. 然后每段黑色连续段长度不超过 \\(k\\) 的方案可以用容斥算出来. 形式化地说, 设 \\( h(n, c) \\) 为将 \\(c\\) 个黑点放进 \\(n\\) 个空位中的方案. 则有 \\[ g(d, \\frac{m}{n / d}) = \\sum_{i = 0}^k (i + 1) h(d - \\frac{m}{n / d} - 1, \\frac{m}{n / d} - i) \\] (乘上 \\((i + 1)\\) 是因为要算最后一段和第一段分别放了多少个黑点.) \\[ h(n, c) = \\sum_{i = 0}^{\\lfloor\\frac{c}{k + 1}\\rfloor} (-1)^i \\binom{n}{i} \\binom{c - i(k + 1) + n - 1}{n - 1} \\] (最后一个组合数是用 插板法 + 可重组合 计算把 \\(c - i(k + 1)\\) 个黑点放进 \\(n\\) 个空位的方案.) 这样每次计算 \\(g(d, \\frac{m}{n / d})\\) 的时间复杂度为 \\( O(k \\lfloor\\frac{\\frac{m}{n / d}}{k + 1}\\rfloor) = O(d)\\), 所以总时间复杂度为 \\( O(\\sigma(n)) \\). ","date":"2021-02-08","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/:2:0","tags":["解题报告","luogu","Burnside引理","数学","计数","容斥"],"title":"[解题报告][luogu4916]魔力环","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 2e5 + 7; const int mod = 998244353; int n, m, K, pri[_], phi[_], v[_], cnt, fac[_], ifac[_], inv[_]; void Init() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e K; if (m == n) { puts(\"0\"); exit(0); } phi[1] = 1; for (int i = 2; i \u003c= n; ++i) { if (!v[i]) pri[++cnt] = i, v[i] = i, phi[i] = i - 1; for (int j = 1; j \u003c= cnt and pri[j] \u003c= v[i] and i * pri[j] \u003c= n; ++j) { v[i * pri[j]] = pri[j]; phi[i * pri[j]] = i % pri[j] ? phi[i] * phi[pri[j]] : phi[i] * pri[j]; } } fac[0] = ifac[0] = inv[1] = 1; for (int i = 1; i \u003c= 2 * n; ++i) { fac[i] = 1ll * fac[i - 1] * i % mod; if (i != 1) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod; } } int C(int n, int m) { return n \u003c 0 or m \u003c 0 ? 0 : 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; } int F(int sum, int num) { if (num == 0) return sum == 0; int res = 0; for (int i = 0; i \u003c= min(sum / (K + 1), num); ++i) { int tmp = 1ll * C(num, i) * C(sum - (K + 1) * i + num - 1, num - 1) % mod; res = (res + ((i \u0026 1) ? mod - tmp : tmp)) % mod; } return res; } int main() { Init(); int ans = 0; for (int d = 1; d \u003c= n; ++d) if (!(n % d) and !(m % (n / d))) { int t = m / (n / d), res = 0; for (int i = 0; i \u003c= min(t, K); ++i) res = (res + 1ll * (i + 1) * F(t - i, d - t - 1) % mod) % mod; ans = (ans + 1ll * res * phi[n / d] % mod) % mod; } cout \u003c\u003c 1ll * ans * inv[n] % mod \u003c\u003c endl; return 0; } ","date":"2021-02-08","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/:3:0","tags":["解题报告","luogu","Burnside引理","数学","计数","容斥"],"title":"[解题报告][luogu4916]魔力环","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/"},{"categories":["OI","解题报告"],"content":"Reference 题解 by yybyyb ","date":"2021-02-08","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/:4:0","tags":["解题报告","luogu","Burnside引理","数学","计数","容斥"],"title":"[解题报告][luogu4916]魔力环","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 一张 \\(n\\) 个点的无向完全图, 每条边可以染上 \\(m\\) 种颜色之一, 求 \\(n!\\) 种点置换下本质不同的染色方案. \\(n \\le 53 \\). ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/:1:0","tags":["解题报告","省选","SHOI","SHOI2006","Burnside引理","Pólya计数定理","数学","计数"],"title":"[解题报告][SHOI2006]有色图","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/"},{"categories":["OI","解题报告"],"content":"Solution 看到置换 + 染色, 先考虑一波 Burnside 引理. (实际上这里用的是 Pólya 计数定理.) 需要注意的是这里是对 边 染色, 对 点 置换, 所以我们要先把 点置换 转成 边置换 后才能用 Burnside 引理做. 我们把一个点置换用循环的形式表示, 即 \\( q_1q_2q_3 \\cdots q_k \\), 其中 \\( q_i \\) 表示该置换的第 \\( i \\) 个循环的大小. 我们这里把 \\(q_i\\) 排序后的结果称为该点置换的 循环表示, 那么可以推导出符合一个循环表示的点置换的数量为 \\[ \\mathrm{tms} = n! \\prod_{i = 1}^k \\frac{1}{q_i} \\prod_{i = 1}^n \\frac{1}{\\#_i} \\] 其中 \\(n!\\) 是为了 \\(n\\) 个点分配到每个循环; \\(\\prod_{i = 1}^k \\frac{1}{q_i}\\) 是因为循环是个圆排列, 所以要除以 \\(q_i\\); \\(\\#_i\\) 表示该置换中大小为 \\(i\\) 的循环的数量, 因为相同的循环之间应该是无序的, 否则会算重. 接下来考虑怎么算边置换. 首先有一个显然的结论, 「循环表示相同的点置换所对应的边置换相同」. 那么我们只需要考虑对于一个循环表示, 它对应的点置换所对应的边置换有多少个循环. (有点绕.) 首先考虑端点在同一个点循环内的边. 容易发现, 在同一个点循环内, 端点距离相同的边构成了一个边循环, 而一个大小为 \\(q_i\\) 的点循环内有 \\( \\lfloor \\frac{q_i}{2} \\rfloor \\) 种端点距离. 所以一个大小为 \\(q_i\\) 点循环可以贡献 \\( \\lfloor \\frac{q_i}{2} \\rfloor \\) 个边循环. 再考虑端点在两个不同点循环内的边. 两个大小分别为 \\(q_1, q_2\\) 的点循环之间有 \\(q_1q_2\\) 条边, 而一个边循环的长度为 \\( lcm(q_1, q_2) = \\frac{q_1q_2}{\\gcd(q_1, q_2)} \\) (画张图可以便于理解), 所以这两个点循环可以贡献 \\( \\gcd(q_1, q_2) \\) 个边循环. 所以一个循环表示为 \\(q_1q_2 \\cdots q_k\\) 的点循环所对应的边置换的循环数量为 \\[ \\mathrm{num} = \\sum_{i = 1}^k \\lfloor \\frac{q_i}{2} \\rfloor + \\sum_{i = 1}^k \\sum_{j = i + 1}^k \\gcd(q_i, q_j) \\] 所以一个循环表示所对应的不动点数量就是 \\[ \\mathrm{tms} \\cdot m^{\\mathrm{num}} \\] 所以只要枚举序列 \\( \\{ q \\} \\) 然后统计它的 \\(\\mathrm{tms}\\) 和 \\(\\mathrm{num}\\) 即可. 设 \\(Q(n)\\) 为点数为 \\(n\\) 的循环表示数量, 即为 \\(n\\) 的划分数. 暴搜一下, 发现 \\(Q(53) = 329931\\). 所以时间复杂度为 \\( O(Q(n)n^2) \\), 然而跑不满 (因为枚举两个点循环那地方不一定是 \\(n^2\\)). 所以是 O(能过). ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/:2:0","tags":["解题报告","省选","SHOI","SHOI2006","Burnside引理","Pólya计数定理","数学","计数"],"title":"[解题报告][SHOI2006]有色图","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 53 + 7; const int __ = 3e3 + 7; int n, m, mod, fac[_], ifac[_], inv[_], pw[__], ans, p[_], gcd[_][_], tot; int Gcd(int a, int b) { return b ? Gcd(b, a % b) : a; } void Dfs(int k, int las, int cnt) { if (k == n) { int tms = fac[n], num = 0; for (int i = 1; i \u003c cnt; ++i) { tms = 1ll * tms * inv[p[i]] % mod; num += p[i] / 2; for (int j = i + 1; j \u003c cnt; ++j) num += gcd[p[i]][p[j]]; } for (int i = 1, j = 1; i \u003c cnt; i = j) { while (j \u003c cnt and p[j] == p[i]) ++j; tms = 1ll * tms * ifac[j - i] % mod; } ans = (ans + 1ll * tms * pw[num] % mod) % mod; tot = (tot + tms) % mod; return; } for (int i = 1; i \u003c= min(las, n - k); ++i) p[cnt] = i, Dfs(k + i, i, cnt + 1); } int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e mod; pw[0] = fac[0] = ifac[0] = inv[1] = 1; for (int i = 1; i \u003c= n; ++i) { if (i != 1) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; fac[i] = 1ll * fac[i - 1] * i % mod; ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod; } for (int i = 1; i \u003c= n * n; ++i) pw[i] = 1ll * pw[i - 1] * m % mod; for (int i = 1; i \u003c= n; ++i) for (int j = 1; j \u003c= n; ++j) gcd[i][j] = Gcd(i, j); Dfs(0, n, 1); cout \u003c\u003c 1ll * ans * ifac[n] % mod \u003c\u003c endl; cerr \u003c\u003c \"tot: \" \u003c\u003c tot \u003c\u003c ' ' \u003c\u003c fac[n] \u003c\u003c endl; return 0; } ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/:3:0","tags":["解题报告","省选","SHOI","SHOI2006","Burnside引理","Pólya计数定理","数学","计数"],"title":"[解题报告][SHOI2006]有色图","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/"},{"categories":null,"content":"Statement 传送门 \\( n \\) 个点, $m$ 种颜色, 颜色为 $i$ 的点有 $a_i$ 个. 求这 $n$ 个点构成的本质不同无标号有序基环树个数. (有序: 子树有序) 两棵基环树本质相同当且仅当通过旋转基环可以使它们相同. $n \\le 2 \\times 10^5$. ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:1:0","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":null,"content":"Solution 旋转基环就是个环同构问题, 那么直接考虑 Burnside 引理. 那么根据一般套路, 可以列出式子 \\[ \\begin{aligned} \\mathrm{ans} \u0026= \\sum_{k = 2}^n \\frac{1}{k} \\sum_{d |k} [\\frac{k}{d} | \\gcd_{i = 1}^m a_i \\wedge \\frac{k}{d} | n]g_{\\frac{n}{k / d}}(d) \\varphi(\\frac{k}{d}) \\\\ \\end{aligned} \\] 其中 \\(g_{n}(m)\\) 为: 环长为 \\(m\\) , 点数为 \\(n\\) 的无标号有序基环树个数. 接下来考虑如何算 \\(g_n(m)\\). 首先考虑节点数为 \\(n\\) 的有根无标号有序树个数怎么算. (不考虑颜色.) 把树的欧拉序看做括号序列, 那么一棵树就唯一地对应一个最外层括号数为 \\(1\\) 的括号序列. (因为要考虑根节点.) 那么方案数也就是第 \\(n - 1\\) 个卡特兰数. 我们设 \\(f_n\\) 为所求方案数, \\(F(x)\\) 为 \\(f_i\\) 的 \\(\\mathrm{OGF}\\). 假设 \\(C(x)\\) 为卡特兰数的 \\(\\mathrm{OGF}\\), 则有 \\(F = xC\\). 再考虑对节点染色. 可以发现染色方案和树的结构是独立的, 所以直接乘上一个染色方案 \\(\\binom{n}{a_1, a_2, \\cdots, a_m}\\) 即可. 那么可以得到 \\[ g_n(k) = [x^n]F^k \\binom{n}{a_1, a_2, \\cdots, a_m} \\] 为了描述更加简洁, 我们默认 \\(\\frac{k}{d} | n\\), 并交换 \\(\\frac{k}{d}\\) 和 \\(d\\). \\[ \\begin{aligned} \\mathrm{ans} \u0026= \\sum_{k = 2}^n \\frac{1}{k} \\sum_{d |k} [d | \\gcd_{i = 1}^m a_i]g_{\\frac{n}{d}}(\\frac{k}{d}) \\varphi(d) \\\\ \u0026= \\sum_{k = 2}^n \\frac{1}{k} \\sum_{d |k} [d | \\gcd_{i = 1}^m a_i][x^{n/d}]F^{k/d}\\binom{n/d}{a_{1 \\cdots m} /d} \\varphi(d) \\\\ \u0026= -f_n \\binom{n}{a_{1 \\cdots m}} + \\sum_{d | \\gcd_{i = 1}^m a_i} \\varphi(d) \\binom{n/d}{a_{1 \\cdots m} /d} [x^{n / d}]\\sum_{t = 1}^{n / d}\\frac{F^{t}}{td} \\\\ \u0026= -f_n \\binom{n}{a_{1 \\cdots m}} + \\sum_{d | \\gcd_{i = 1}^m a_i} \\frac{\\varphi(d)}{d} \\binom{n/d}{a_{1 \\cdots m} /d} [x^{n / d}]\\sum_{t = 1}^{+\\infty}\\frac{F^{t}}{t} \\\\ \\end{aligned} \\] 第二行到第三行是交换枚举顺序, 并用 \\(t\\) 代替 \\(\\frac{k}{d}\\). 接下来有两种推导方法. ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:2:0","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":null,"content":"一 我们有结论 \\(\\sum_{i = 1}^{+ \\infty} \\frac{x^i}{i} = \\ln(1 - x)\\), 所以原式化为 \\[ \\mathrm{ans} = -f_n \\binom{n}{a_{1 \\cdots m}} + \\sum_{d | \\gcd_{i = 1}^m a_i} \\frac{\\varphi(d)}{d} \\binom{n/d}{a_{1 \\cdots m} /d} [x^{n / d}]\\sum_{t = 1}^{+\\infty}\\ln(1 - F) \\] 多项式 \\(\\ln\\) 求一下即可. 时间复杂度为 \\(O(n \\log n + \\sigma(n))\\). (\\(\\sigma(n)\\) 表示 \\(n\\) 的约数和, 大概是 \\(O(n)\\) 级别的.) ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:2:1","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":null,"content":"二 卡特兰数生成函数的幂有个性质 \\[ [x^n] C^m = \\binom{2n - m - 1}{n - m} - \\binom{2n - m - 1}{n - m - 1} \\] 然后把这个带进 \\(F^t\\) 即可得到 \\[ \\mathrm{ans} = -f_n \\binom{n}{a_{1 \\cdots m}} + \\sum_{d | \\gcd_{i = 1}^m a_i} \\frac{\\varphi(d)}{d} \\binom{n/d}{a_{1 \\cdots m} /d} \\sum_{t = 1}^{n / d} \\frac{1}{t} \\binom{2n / d - k - 1}{n / d - k} \\binom{2n / d - k - 1}{n / d - k - 1} \\] 时间复杂度为 \\(O(\\sigma(n))\\). ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:2:2","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":null,"content":"Code #include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 4e5 + 7; const int mod = 998244353; int n, m, a[_], gcda; int pri[_], v[_], phi[_], cnt; int fac[_], ifac[_], inv[_]; int Gcd(int a, int b) { return b ? Gcd(b, a % b) : a; } void Init() { cin \u003e\u003e n \u003e\u003e m; gcda = n; for (int i = 1; i \u003c= m; ++i) { scanf(\"%d\", \u0026a[i]); gcda = Gcd(gcda, a[i]); } phi[1] = 1; for (int i = 2; i \u003c= n; ++i) { if (!v[i]) pri[++cnt] = i, v[i] = i, phi[i] = i - 1; for (int j = 1; j \u003c= cnt and pri[j] \u003c= v[i] and i * pri[j] \u003c= n; ++j) { v[i * pri[j]] = pri[j]; phi[i * pri[j]] = (i % pri[j]) ? phi[i] * phi[pri[j]] : phi[i] * pri[j]; } } fac[0] = ifac[0] = inv[1] = 1; for (int i = 1; i \u003c= 2 * n; ++i) { if (i != 1) inv[i] = 1ll * inv[mod % i] * (mod - mod / i ) % mod; fac[i] = 1ll * fac[i - 1] * i % mod; ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod; } } int Ch(int d) { int res = fac[n / d]; assert(!(n % d)); for (int i = 1; i \u003c= m; ++i) res = 1ll * res * ifac[a[i] / d] % mod, assert(!(a[i] % d)); return res; } int C(int n, int m) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; } int main() { Init(); int ans = (mod - 1ll * (C(2 * (n - 1), n - 1) - C(2 * (n - 1), n - 2) + mod) * Ch(1) % mod) % mod; for (int d = 1; d \u003c= gcda; ++d) if (!(gcda % d)) { int res = 0; for (int k = 1; k \u003c= n / d; ++k) res = (res + 1ll * (C(2 * n / d - k - 1, n / d - k) - C(2 * n / d - k - 1, n / d - k - 1) + mod) * inv[k] % mod) % mod; ans = (ans + 1ll * Ch(d) * phi[d] % mod * inv[d] % mod * res % mod) % mod; } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:3:0","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":null,"content":"Reference 题解 by PinkRabbit ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:4:0","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":["OI","解题报告"],"content":"题意 若一个拆分方式能把一个串表示为 \\(AABB\\) 的形式, 则称这个拆分为 \"优秀的拆分\". 给定一个串 \\(S\\), 求它所有子串的所有 \"优秀的划分\" 数量总和. \\(T\\) 组数据, \\( T \\le 10,\\ n \\le 30000 \\) ","date":"2021-01-31","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/:0:1","tags":["解题报告","SA","字符串","NOI","NOI2016"],"title":"[解题报告] [NOI2016]优秀的拆分","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/"},{"categories":["OI","解题报告"],"content":"解法 首先可以想到在 \\(AA\\) 和 \\(BB\\) 之间的那个位置统计答案, 那么我们就需要对每个位置 \\(i\\) 算出以它为起点 / 终点的形如 \\(AA\\) 的串个数. 计算这个要用到一个 \"撒点\" 的套路. 具体来说就是枚举 \\(AA\\) 的长度 \\(len\\), 然后把原串 \\(S\\) 分为形如 \\([1,len],\\ [len + 1, 2len], \\cdots, [klen + 1, n] \\) 的若干个子串. 然后我们对相邻的子串分别求出它们的 \\(LCP\\) 和 \\(LCS\\) (最长公共前缀和最长公共后缀). 然后稍微画一下就可以找出哪些位置可以作为长度为 \\(2len\\) 的 \\(AA\\) 串的起点或终点, 对于两个相邻的子串来说, 这些点会构成一个区间, 所以用差分实现一下区间加即可. 对于每个 \\(len\\), 处理一次的复杂度是 \\(O(\\frac{n}{len})\\) 的, 所以总复杂度为 \\( O(\\sum_i \\frac{n}{i}) = O(n\\log n) \\). 然后求 \\(LCP\\) 和 \\(LCS\\) 用 SA 或者 SAM 即可. (当然二分加哈希也不是不可以, 不过就是多了个 \\(\\log\\).) ","date":"2021-01-31","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/:0:2","tags":["解题报告","SA","字符串","NOI","NOI2016"],"title":"[解题报告] [NOI2016]优秀的拆分","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/"},{"categories":["OI","解题报告"],"content":"代码 #include \u003calgorithm\u003e#include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; typedef long long ll; const int _ = 1e5 + 7; const int L = 15; int n, Log[_], f[2][_][L + 7], num[2][_]; char S[_]; int rk[2][_], sa[_], c[_], t[_], trk[_]; void GetSa(bool ty) { for (int i = 0; i \u003c= max(n, (int)'z'); ++i) c[i] = 0; for (int i = 0; i \u003c= 2 * n; ++i) rk[ty][i] = 0; // notice that the upper bound here needs to be 2n for (int i = 1; i \u003c= n; ++i) rk[ty][i] = S[i], ++c[rk[ty][i]]; for (int i = 1; i \u003c= 'z'; ++i) c[i] += c[i - 1]; for (int i = 1; i \u003c= n; ++i) sa[c[rk[ty][i]]--] = i; for (int len = 1; len \u003c n; len \u003c\u003c= 1) { for (int i = 0; i \u003c= n; ++i) c[i] = 0; for (int i = 1; i \u003c= n; ++i) ++c[rk[ty][i]]; for (int i = 1; i \u003c= n; ++i) c[i] += c[i - 1]; for (int i = n; i \u003e= 1; --i) if (sa[i] \u003e len) t[c[rk[ty][sa[i] - len]]--] = sa[i] - len; for (int i = n - len + 1; i \u003c= n; ++i) t[c[rk[ty][i]]--] = i; for (int i = 1; i \u003c= n; ++i) sa[i] = t[i]; int cnt = 0; for (int i = 1; i \u003c= n; ++i) trk[sa[i]] = (i == 1 or rk[ty][sa[i]] != rk[ty][sa[i - 1]] or rk[ty][sa[i] + len] != rk[ty][sa[i - 1] + len]) ? ++cnt : cnt; for (int i = 1; i \u003c= n; ++i) rk[ty][i] = trk[i]; } } int hgt[_]; void GetHgt(bool ty) { for (int i = 0; i \u003c= n; ++i) hgt[i] = 0; for (int i = 1; i \u003c= n; ++i) { int j = sa[rk[ty][i] - 1]; hgt[rk[ty][i]] = max(0, hgt[rk[ty][i - 1]] - 1); while (max(i, j) + hgt[rk[ty][i]] \u003c= n and S[i + hgt[rk[ty][i]]] == S[j + hgt[rk[ty][i]]]) ++hgt[rk[ty][i]]; } for (int i = 1; i \u003c= n; ++i) f[ty][i][0] = hgt[i]; for (int l = 1; l \u003c= L; ++l) for (int i = 1; i + (1 \u003c\u003c (l - 1)) \u003c= n; ++i) f[ty][i][l] = min(f[ty][i][l - 1], f[ty][i + (1 \u003c\u003c (l - 1))][l - 1]); } int Query(bool ty, int l, int r) { assert(l != r); if (ty) l = rk[1][n - l + 1], r = rk[1][n - r + 1]; else l = rk[0][l], r = rk[0][r]; if (l \u003e r) swap(l, r); ++l; int s = Log[r - l + 1]; return min(f[ty][l][s], f[ty][r - (1 \u003c\u003c s) + 1][s]); } int main() { for (int i = 1; i \u003c= 30000; ++i) Log[i] = (i == (1 \u003c\u003c (Log[i - 1] + 1))) ? Log[i - 1] + 1 : Log[i - 1]; int T; cin \u003e\u003e T; while (T--) { scanf(\"%s\", S + 1); n = strlen(S + 1); for (int t = 0; t \u003c 2; ++t) { GetSa(t), GetHgt(t); reverse(S + 1, S + n + 1); } for (int t = 0; t \u003c 2; ++t) for (int i = 1; i \u003c= n; ++i) num[t][i] = 0; for (int l = 1; l \u003c= n; ++l) for (int i = 1; i + 2 * l - 1 \u003c= n; i += l) { int len1 = min(l, Query(1, i + l - 1, i + 2 * l - 1)), len2 = min(l, Query(0, i + l, i + 2 * l)); int p1 = i + l - len1, p2 = min(i + l + len2 - 1, i + 2 * l - 2); if (p1 \u003c= p2 - l + 1) { ++num[1][p1], --num[1][p2 - l + 2]; ++num[0][p1 + 2 * l - 1], --num[0][p2 + l + 1]; } } long long ans = 0; for (int i = 1; i \u003c= n; ++i) num[0][i] += num[0][i - 1], num[1][i] += num[1][i - 1]; for (int i = 1; i \u003c n; ++i) ans += 1ll * num[0][i] * num[1][i + 1]; cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2021-01-31","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/:0:3","tags":["解题报告","SA","字符串","NOI","NOI2016"],"title":"[解题报告] [NOI2016]优秀的拆分","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/"},{"categories":null,"content":"配置 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:1:0","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"用户信息 ~$ git config --global user.name Example ~$ git config --global user.email Example@Example.com ### 编辑器 ```bash ~$ git config --global core.editor emacs ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:1:1","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"基础操作 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:2:0","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"新建仓库 ~/xxx$ git init ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:2:1","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"拷贝仓库 ~$ git clone https://github.com/BruceW-07/brucew-07.github.io.git ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:2:2","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"跟踪文件 查看仓库状态 ~/xxx$ git status 将文件放入暂存区 ~/xxx$ git add README.md 如果需要将所有文件全部放入暂存区，可以使用参数 -A ~/xxx$ git add -a 但需要注意的是，git add 命令只会将文件放入暂存区，并没有真正提交这次修改。 将文件提交至 Git ~/xxx$ git commit 接下来会弹出一个编辑器窗口，输入 commit 并保存退出即可。 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:2:3","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"远程操作 将 Git 中信息推送至服务器 例如，将信息推送至 origin 仓库中的 master 分支 ~/xxx$ git push origin master ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:3:0","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"原因 最近又开始尝试搭建自己的博客了，还是 github 托管的方案，不过从 Hexo 换成了 Hugo。 上次尝试失败的原因貌似是不知道怎么将博客迁移到其他电脑上（毕竟我还没有自己的电脑，所以有在机房不同电脑上迁移的需求）。 现在博客的配置已经基本完成了，为防止再次弃坑，打算来系统学一下 Git，顺便丰富一下自己的知识库。 现在是 2021-01-29，星期五，晚上组里休息，那就开始吧。 参考资料 [洛谷日报#199]Git 简单上手指南 by Studying Father ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"配置 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"用户信息 ~$ git config --global user.name Example ~$ git config --global user.email Example@Example.com 这里的 --global 表示对系统中的所有仓库均有效，如果只想对单个仓库进行配置，只需在仓库的目录下执行去掉 --global 的命令即可。 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"设置编辑器 ~$ git config --global core.editor emacs ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"基础操作 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"新建仓库 首先新建一个文件夹作为你的仓库，例如 ~$ mkdir xxx 然后进入这个文件夹，并使用 git init 命令初始化仓库 ~$ cd xxx ~/xxx$ git init Git 将在 ~/xxx 目录中新建一个文件夹 .git。输入指令 ls -a，将会看到 ~/xxx$ ls -a . .. .git ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"拷贝仓库 使用 git clone 命令可以远程拷贝先前创建的仓库，如 ~$ git clone https://github.com/BruceW-07/brucew-07.github.io.git （是的这是我博客部署文件的仓库地址） ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"跟踪文件 我们对仓库进行了一些修改后，需要将这些修改纳入版本管理中（我将其理解为推送到云备份上）。 而当我们不确定在上一次备份后进行了那些修改时，我们可以使用 git status 命令来查看当前仓库文件的状态。 当我们没有对仓库进行修改时，输入 git status 命令，将会显示以下内容 ~/xxx$ git status On branch master Initial commit nothing to commit (create/copy files and use \"git add\" to track) 而当我们对仓库进行了修改，比如说新建了一个 README.md 文件后，再输入 git status 命令，将会显示 ~/xxx$ touch README.md ~/xxx$ git status On branch master Initial commit Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) README.md nothing added to commit but untracked files present (use \"git add\" to track) 这里 Untracked files 指的是 Git 之前没有纳入版本跟踪的文件。 参考资料中说 如果文件没有纳入版本跟踪，我们对该文件的修改不会被 Git 记录。 不是特别理解，不过大概就那个意思吧。 然后我们可以使用 git add 命令将这个文件纳入版本跟踪 ~/xxx$ git add README.md 这时我们再输入 git status，就会显示 ~/xxx$ git status On branch master Initial commit Changes to be committed: (use \"git rm --cached \u003cfile\u003e...\" to unstage) new file: README.md 表示 README.md 已经纳入了版本跟踪。 但需要注意的是，git add 命令只会将文件放入暂存区，并没有真正提交这次修改，我们需要使用 git commit 命令来将暂存区的文件提交到 Git 上 ~/xxx$ git commit 接下来会弹出一个编辑器窗口，里面显示 # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # On branch master # # Initial commit # # Changes to be committed: # new file: README.md # 我们只需要在第一行输入 commit commit # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # On branch master # # Initial commit # # Changes to be committed: # new file: README.md # 然后保存并退出即可。 终端中便会显示 [master (root-commit) 8c68837] commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README.md 表示 README.md 已经成功从暂存区提交到 Git 上了。 我们再使用 git status 命令来查看一下仓库状态 ~/xxx$ git status On branch master nothing to commit, working directory clean 一干二净 我们再来考虑一种情况：对于一个文件 README.md，假如我们先用 git add 命令将它放入暂存区中，这时我们先不使用 git commit 命令提交，而是再修改一下 README.md，然后不把它重新放入暂存区，而是直接提交，会发生什么呢？ 让我们来尝试一下。 先修改一波 README.md ~/xxx$ emacs README.md # 随便写些东西（记得保存） 然后把它放进暂存区 ~/xxx$ git add README.md 检查一下 ~/xxx$ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: README.md 然后再修改一波 ~/xxx$ emacs README.md # 再随便写些东西 看看现在的状态 ~/xxx$ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: README.md Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md 然后现在我们提交，并查看仓库状态 ~/xxx$ git commit # 在弹出的编辑器窗口中输入 \"commit\"，保存并退出 [master ac7a776] commit 1 file changed, 1 insertion(+) ~/xxx$ git status On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") 发现在暂缓区中的 README.md 被提交到 Git 上了，而非暂缓区中的 README.md 仍只保存在本地 我们发现在刚才使用 git status 命令中，有这么两句话 (use \"git reset HEAD \u003cfile\u003e...\" to unstage) 和 (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) 从字面意思以及结合上下文理解上看，第一条命令会使得暂缓区中对 README.md 的修改会被撤回，而第二条命令会使得非暂缓区中对 README.md 的修改被撤销。 我们一个个来试一下。 首先还是先修改 README.md，设内容为 first， 然后 git add， 然后再修改 README.md，设内容为 second， 再输入 git status，显示 ~/xxx$ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: README.md Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md 接着按照它的提示，输入 ~/xxx$ git reset README.md Unstaged changes after reset: M README.md 再输入 git status ~/xxx$ git status On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") 发现暂存区中的 README.md 消失了。打开","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]